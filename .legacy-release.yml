
.get_release_name_legacy: &get_release_name_legacy |
  # using annotated tags
  REL_NUM=$(git describe --abbrev=7)
  REL_SFX="llvm15_0_0"
  REL_NAME=${CONF_TARGET}-${REL_SFX}-${REL_NUM}-${PLATFORM_NAME}
  ARCHIVE_NAME=${REL_NAME}.${ARCHIVE_EXT}
  echo "PLATFORM_NAME: $PLATFORM_NAME"
  echo "REL_NUM: $REL_NUM"
  echo "REL_NAME: $REL_NAME"
  echo "ARCHIVE_NAME: $ARCHIVE_NAME"

.get_gcc_toolchain_legacy: &get_gcc_toolchain_legacy |
  wget --no-verbose https://dl.espressif.com/github_assets/espressif/crosstool-NG/releases/download/esp-2021r2-patch3/${XTENSA_GCC_TOOLCHAIN}
  ${UNARCHIVE_TOOL} ${XTENSA_GCC_TOOLCHAIN}
  if [[ "$XTENSA_GCC_TOOLCHAIN" == *"linux-amd64"* ]]; then
    cp -r xtensa-esp32-elf ${XTENSA_CLANG_TOOLCHAIN}
  else
    mv xtensa-esp32-elf ${XTENSA_CLANG_TOOLCHAIN}
    wget --no-verbose https://dl.espressif.com/github_assets/espressif/crosstool-NG/releases/download/esp-2021r2-patch3/xtensa-esp32-elf-${GCC_REL_NAME}-linux-amd64.tar.gz
    tar -xf xtensa-esp32-elf-${GCC_REL_NAME}-linux-amd64.tar.gz
  fi
  export GCC_ESP32_LINUX_TOOLCHAIN="xtensa-esp32-elf"

.package_toolchain_legacy: &package_toolchain_legacy |
  ${ARCHIVE_TOOL} ${ARCHIVE_NAME} ${XTENSA_CLANG_TOOLCHAIN}/
  mkdir -p ${DIST_DIR}
  mv ${ARCHIVE_NAME} ${DIST_DIR}/
  echo "${ARCHIVE_NAME}" > ${DIST_DIR}/file_${PLATFORM_NAME}_${CONF_TARGET}

.build_template_legacy:
  stage: build
  tags: [ "amd64", "build" ]
  artifacts:
    paths:
      - ${DIST_DIR}/
    when: always
    expire_in: 10 day
  variables:
    XTENSA_CLANG_TOOLCHAIN_REF: "release_esp32_clang_15.0.0_gcc_8.4.0"
    GCC_REL_NAME: "gcc8_4_0-esp-2021r2-patch3"
  script:
    - *get_release_name_legacy
    - *get_gcc_toolchain_legacy
    - !reference [.fix_origin_remote_for_public, script]
    - !reference [.get_clang_toolchain_build_scripts, script]
    - ${BUILD_TOOLCHAIN_CMD} "${XTENSA_CLANG_TOOLCHAIN}"
    - *package_toolchain_legacy

linux_amd64_build:
  extends: .build_template_legacy
  variables:
    PLATFORM_NAME: "${PLATFORM_NAME_LINUX}"
    ARCHIVE_TOOL: "${ARCHIVE_TOOL_LINUX}"
    UNARCHIVE_TOOL: "${UNARCHIVE_TOOL_LINUX}"
    ARCHIVE_EXT: "${ARCHIVE_EXT_LINUX}"
    XTENSA_GCC_TOOLCHAIN: "xtensa-esp32-elf-${GCC_REL_NAME}-linux-amd64.tar.gz"
    BUILD_TOOLCHAIN_CMD: "./build-toolchain-linux.sh"

linux_arm64_build:
  extends: .build_template_legacy
  image: ${CROSS_ARM_IMAGE}
  variables:
    PLATFORM_NAME: "${PLATFORM_NAME_LINUX_ARM64}"
    ARCHIVE_TOOL: "${ARCHIVE_TOOL_LINUX}"
    UNARCHIVE_TOOL: "${UNARCHIVE_TOOL_LINUX}"
    ARCHIVE_EXT: "${ARCHIVE_EXT_LINUX}"
    XTENSA_GCC_TOOLCHAIN: "xtensa-esp32-elf-${GCC_REL_NAME}-linux-arm64.tar.gz"
    BUILD_TOOLCHAIN_CMD: "./build-toolchain-linux-arm64.sh"

win64_build:
  extends: .build_template_legacy
  variables:
    PLATFORM_NAME: "${PLATFORM_NAME_WIN}"
    ARCHIVE_TOOL: "${ARCHIVE_TOOL_WIN}"
    UNARCHIVE_TOOL: "${UNARCHIVE_TOOL_WIN}"
    ARCHIVE_EXT: "${ARCHIVE_EXT_WIN}"
    XTENSA_GCC_TOOLCHAIN: "xtensa-esp32-elf-${GCC_REL_NAME}-win64.zip"
    BUILD_TOOLCHAIN_CMD: "./build-toolchain-win.sh"

macos_amd64_build:
  extends: .build_template_legacy
  variables:
    PLATFORM_NAME: "${PLATFORM_NAME_MACOS}"
    ARCHIVE_TOOL: "${ARCHIVE_TOOL_MACOS}"
    UNARCHIVE_TOOL: "${UNARCHIVE_TOOL_MACOS}"
    ARCHIVE_EXT: "${ARCHIVE_EXT_MACOS}"
    XTENSA_GCC_TOOLCHAIN: "xtensa-esp32-elf-${GCC_REL_NAME}-macos.tar.gz"
    BUILD_TOOLCHAIN_CMD: "./build-toolchain-macos.sh"

linux_amd64_testsuite:
  stage: test
  tags: [ "amd64", "build" ]
  needs:
    - job: linux_amd64_build
  variables:
    PLATFORM_NAME: "${PLATFORM_NAME_LINUX}"
    ARCHIVE_TOOL: "${ARCHIVE_TOOL_LINUX}"
    UNARCHIVE_TOOL: "${UNARCHIVE_TOOL_LINUX}"
    ARCHIVE_EXT: "${ARCHIVE_EXT_LINUX}"
    LLVM_GCC_TESTSUITE_REF: "feature/ci_llvm_multitarget_crt_tests"
  script:
    - *get_release_name_legacy
    - ${UNARCHIVE_TOOL} ${DIST_DIR}/${ARCHIVE_NAME}

    # getting testsuite
    - git clone -b ${LLVM_GCC_TESTSUITE_REF} --depth 1 $GITLAB_SSH_SERVER/idf/${LLVM_TESTSUITE_REPO}.git

    # preparing testsuite
    - export PATH=${PWD}/${XTENSA_CLANG_TOOLCHAIN}/bin/:$PATH
    - cd ${LLVM_TESTSUITE_REPO}

    # qemu
    - ./qemu_esp32_install.sh

    # run testsuite for esp32
    - ./run_esp32_tests.sh

    # run testsuite for compiler_rt library
    - ./run_esp32_crt_tests.sh ../$XTENSA_CLANG_TOOLCHAIN

upload_to_http_legacy:
  stage: private_deploy
  when: manual
  allow_failure: true
  tags: [ "deploy", "shiny" ]
  variables:
    # force the fetch strategy to clean old archives up in dist/ dir
    GIT_STRATEGY: fetch
  before_script:
    - !reference [.use_ci_tools, script]
  script:
    - cit_add_ssh_key "${HTTP_UPLOAD_KEY}"
    # List of archives
    - FILES=$(find ${DIST_DIR} -name file_\* -exec cat {} \+)
    - cd ${DIST_DIR}
    - scp ${FILES} ${HTTP_UPLOAD_DIR}/ct-ng/llvm-builds
    # Show info
    - echo -e "\nArchives were published there:\n\n$(for n in ${FILES}; do echo "${HTTP_PUBLIC_DIR}/ct-ng/llvm-builds/${n}"; done)\n"

upload_to_github_legacy:
  stage: public_deploy
  when: manual
  allow_failure: true
  only:
    - tags
  tags: [ "amd64", "internet" ]
  image: espressif/github-hub:2
  variables:
    GIT_STRATEGY: fetch
    GITHUB_TOKEN: "${GH_TOKEN}"
    GITHUB_REPO: "${GH_REPO_HTTPS}"
    TAG: "${CI_COMMIT_TAG}"
  before_script: []
  script:
    - ls -l dist*/
    - git remote add github ${GH_REPO_HTTPS}
    - hub release show ${TAG} || { echo "Please create a release on GitHub with ${TAG} tag at first"; exit 1; }
    # List of archives
    - FILES=$(find ${DIST_DIR} -name file_\* -exec cat {} \+)
    - cd ${DIST_DIR}
    - ls -l $FILES
    # Upload archives
    - for n in ${FILES}; do hub release edit -m "" -a "${n}" "${TAG}"; done
