; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; ModuleID = './riscv-esp32p4-bitwise.c'
; Test ASM generation (Intrinsic -> ASM)
; RUN: llc -O2 -mcpu=esp32p4 -mtriple=riscv32 %s -o - | FileCheck %s --check-prefix=ASM

define dso_local void @test_andq(ptr noundef %src1, ptr noundef %src2, ptr noundef %dst) local_unnamed_addr #0 {
; ASM-LABEL: test_andq:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    esp.vld.128.ip q0, a0, 16
; ASM-NEXT:    esp.vld.128.ip q1, a1, 16
; ASM-NEXT:    esp.andq q0, q0, q1
; ASM-NEXT:    esp.vst.128.ip q0, a2, 16
; ASM-NEXT:    ret
entry:
  %0 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr %src1, i32 16)
  %1 = extractvalue { <16 x i8>, ptr } %0, 0
  %2 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr %src2, i32 16)
  %3 = extractvalue { <16 x i8>, ptr } %2, 0
  %4 = tail call <16 x i8> @llvm.riscv.esp.andq.m(<16 x i8> %1, <16 x i8> %3)
  %5 = tail call ptr @llvm.riscv.esp.vst.128.ip.m(<16 x i8> %4, ptr %dst, i32 16)
  ret void
}

declare <16 x i8> @llvm.riscv.esp.andq.m(<16 x i8>, <16 x i8>) #1

define dso_local void @test_orq(ptr noundef %src1, ptr noundef %src2, ptr noundef %dst) local_unnamed_addr #0 {
; ASM-LABEL: test_orq:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    esp.vld.128.ip q0, a0, 16
; ASM-NEXT:    esp.vld.128.ip q1, a1, 16
; ASM-NEXT:    esp.orq q0, q0, q1
; ASM-NEXT:    esp.vst.128.ip q0, a2, 16
; ASM-NEXT:    ret
entry:
  %0 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr %src1, i32 16)
  %1 = extractvalue { <16 x i8>, ptr } %0, 0
  %2 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr %src2, i32 16)
  %3 = extractvalue { <16 x i8>, ptr } %2, 0
  %4 = tail call <16 x i8> @llvm.riscv.esp.orq.m(<16 x i8> %1, <16 x i8> %3)
  %5 = tail call ptr @llvm.riscv.esp.vst.128.ip.m(<16 x i8> %4, ptr %dst, i32 16)
  ret void
}

declare <16 x i8> @llvm.riscv.esp.orq.m(<16 x i8>, <16 x i8>) #1

define dso_local void @test_xorq(ptr noundef %src1, ptr noundef %src2, ptr noundef %dst) local_unnamed_addr #0 {
; ASM-LABEL: test_xorq:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    esp.vld.128.ip q0, a0, 16
; ASM-NEXT:    esp.vld.128.ip q1, a1, 16
; ASM-NEXT:    esp.xorq q0, q0, q1
; ASM-NEXT:    esp.vst.128.ip q0, a2, 16
; ASM-NEXT:    ret
entry:
  %0 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr %src1, i32 16)
  %1 = extractvalue { <16 x i8>, ptr } %0, 0
  %2 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr %src2, i32 16)
  %3 = extractvalue { <16 x i8>, ptr } %2, 0
  %4 = tail call <16 x i8> @llvm.riscv.esp.xorq.m(<16 x i8> %1, <16 x i8> %3)
  %5 = tail call ptr @llvm.riscv.esp.vst.128.ip.m(<16 x i8> %4, ptr %dst, i32 16)
  ret void
}

declare <16 x i8> @llvm.riscv.esp.xorq.m(<16 x i8>, <16 x i8>) #1

define dso_local void @test_notq(ptr noundef %src, ptr noundef %dst) local_unnamed_addr #0 {
; ASM-LABEL: test_notq:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    esp.vld.128.ip q0, a0, 16
; ASM-NEXT:    esp.notq q0, q0
; ASM-NEXT:    esp.vst.128.ip q0, a1, 16
; ASM-NEXT:    ret
entry:
  %0 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr %src, i32 16)
  %1 = extractvalue { <16 x i8>, ptr } %0, 0
  %2 = tail call <16 x i8> @llvm.riscv.esp.notq.m(<16 x i8> %1)
  %3 = tail call ptr @llvm.riscv.esp.vst.128.ip.m(<16 x i8> %2, ptr %dst, i32 16)
  ret void
}

declare <16 x i8> @llvm.riscv.esp.notq.m(<16 x i8>) #1

define dso_local void @test_zero_q(ptr noundef %dst) local_unnamed_addr #2 {
; ASM-LABEL: test_zero_q:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    esp.zero.q q0
; ASM-NEXT:    esp.vst.128.ip q0, a0, 16
; ASM-NEXT:    ret
entry:
  %0 = tail call <16 x i8> @llvm.riscv.esp.zero.q.m()
  %1 = tail call ptr @llvm.riscv.esp.vst.128.ip.m(<16 x i8> %0, ptr %dst, i32 16)
  ret void
}

declare <16 x i8> @llvm.riscv.esp.zero.q.m() #1

define dso_local void @test_zero_qacc(ptr noundef %dst) local_unnamed_addr #2 {
; ASM-LABEL: test_zero_qacc:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    esp.zero.qacc
; ASM-NEXT:    esp.st.qacc.l.l.128.ip a0, 16
; ASM-NEXT:    ret
entry:
  %0 = tail call { <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8> } @llvm.riscv.esp.zero.qacc.m()
  %1 = extractvalue { <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8> } %0, 0
  %2 = tail call ptr @llvm.riscv.esp.st.qacc.l.l.128.ip.m(<16 x i8> %1, ptr %dst, i32 16)
  ret void
}

declare { <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8> } @llvm.riscv.esp.zero.qacc.m() #1

declare ptr @llvm.riscv.esp.st.qacc.l.l.128.ip.m(<16 x i8>, ptr, i32) #3

define dso_local void @test_zero_qacc_use_l(ptr noundef %dst, ptr noundef readonly captures(none) %qx, ptr noundef readonly captures(none) %qy) local_unnamed_addr #0 {
; ASM-LABEL: test_zero_qacc_use_l:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    esp.vld.128.ip q0, a1, 0
; ASM-NEXT:    esp.vld.128.ip q1, a2, 0
; ASM-NEXT:    esp.zero.qacc
; ASM-NEXT:    esp.vcmulas.s16.qacc.l q0, q1
; ASM-NEXT:    esp.st.qacc.l.l.128.ip a0, 16
; ASM-NEXT:    ret
entry:
  %0 = tail call { <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8> } @llvm.riscv.esp.zero.qacc.m()
  %1 = extractvalue { <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8> } %0, 0
  %2 = extractvalue { <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8> } %0, 1
  %3 = load <8 x i16>, ptr %qx, align 16
  %4 = load <8 x i16>, ptr %qy, align 16
  %5 = tail call { <16 x i8>, <16 x i8> } @llvm.riscv.esp.vcmulas.s16.qacc.l.m(<16 x i8> %1, <16 x i8> %2, <8 x i16> %3, <8 x i16> %4)
  %6 = extractvalue { <16 x i8>, <16 x i8> } %5, 0
  %7 = tail call ptr @llvm.riscv.esp.st.qacc.l.l.128.ip.m(<16 x i8> %6, ptr %dst, i32 16)
  ret void
}

declare { <16 x i8>, <16 x i8> } @llvm.riscv.esp.vcmulas.s16.qacc.l.m(<16 x i8>, <16 x i8>, <8 x i16>, <8 x i16>) #1

define dso_local void @test_zero_qacc_use_h(ptr noundef %dst, ptr noundef readonly captures(none) %qx, ptr noundef readonly captures(none) %qy) local_unnamed_addr #0 {
; ASM-LABEL: test_zero_qacc_use_h:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    esp.vld.128.ip q0, a1, 0
; ASM-NEXT:    esp.vld.128.ip q1, a2, 0
; ASM-NEXT:    esp.zero.qacc
; ASM-NEXT:    esp.vcmulas.s16.qacc.h q0, q1
; ASM-NEXT:    esp.st.qacc.h.h.128.ip a0, 16
; ASM-NEXT:    ret
entry:
  %0 = tail call { <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8> } @llvm.riscv.esp.zero.qacc.m()
  %1 = extractvalue { <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8> } %0, 2
  %2 = extractvalue { <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8> } %0, 3
  %3 = load <8 x i16>, ptr %qx, align 16
  %4 = load <8 x i16>, ptr %qy, align 16
  %5 = tail call { <16 x i8>, <16 x i8> } @llvm.riscv.esp.vcmulas.s16.qacc.h.m(<16 x i8> %1, <16 x i8> %2, <8 x i16> %3, <8 x i16> %4)
  %6 = extractvalue { <16 x i8>, <16 x i8> } %5, 1
  %7 = tail call ptr @llvm.riscv.esp.st.qacc.h.h.128.ip.m(<16 x i8> %6, ptr %dst, i32 16)
  ret void
}

declare { <16 x i8>, <16 x i8> } @llvm.riscv.esp.vcmulas.s16.qacc.h.m(<16 x i8>, <16 x i8>, <8 x i16>, <8 x i16>) #1

declare ptr @llvm.riscv.esp.st.qacc.h.h.128.ip.m(<16 x i8>, ptr, i32) #3

define dso_local ptr @test_zero_qacc_use_both(ptr noundef %dst_l, ptr noundef %dst_h) local_unnamed_addr #2 {
; ASM-LABEL: test_zero_qacc_use_both:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    esp.zero.qacc
; ASM-NEXT:    esp.st.qacc.l.l.128.ip a0, 16
; ASM-NEXT:    esp.st.qacc.h.h.128.ip a1, 16
; ASM-NEXT:    mv a0, a1
; ASM-NEXT:    ret
entry:
  %0 = tail call { <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8> } @llvm.riscv.esp.zero.qacc.m()
  %1 = extractvalue { <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8> } %0, 0
  %2 = extractvalue { <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8> } %0, 3
  %3 = tail call ptr @llvm.riscv.esp.st.qacc.l.l.128.ip.m(<16 x i8> %1, ptr %dst_l, i32 16)
  %4 = tail call ptr @llvm.riscv.esp.st.qacc.h.h.128.ip.m(<16 x i8> %2, ptr %dst_h, i32 16)
  ret ptr %4
}

declare { i32, i32 } @llvm.riscv.esp.zero.xacc.m() #1

declare { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr, i32) #6

declare ptr @llvm.riscv.esp.vst.128.ip.m(<16 x i8>, ptr, i32) #3

declare { ptr, i32, i32 } @llvm.riscv.esp.st.s.xacc.ip.m(i32, i32, ptr, i32) #3

attributes #0 = { "target-features"="+32bit,+xespv" }
attributes #1 = { nounwind }
attributes #2 = { "target-features"="+32bit,+xespv" }
attributes #3 = { nounwind }
attributes #4 = { "target-features"="+32bit,+xespv" }
attributes #5 = { nounwind }
attributes #6 = { nounwind }


