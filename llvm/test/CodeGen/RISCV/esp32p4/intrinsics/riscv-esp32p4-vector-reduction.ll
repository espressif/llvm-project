; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; ModuleID = './riscv-esp32p4-vector-reduction.c'
; Test ASM generation (Intrinsic -> ASM)
; RUN: llc -O2 -mattr=xespv2p1 -mtriple=riscv32 %s -o - | FileCheck %s --check-prefix=ASM

define dso_local i32 @test_max_s8(ptr noundef %src) local_unnamed_addr #0 {
; ASM-LABEL: test_max_s8:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    esp.vld.128.ip q0, a0, 16
; ASM-NEXT:    esp.max.s8.a q0, a0
; ASM-NEXT:    ret
entry:
  %0 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr %src, i32 16)
  %1 = extractvalue { <16 x i8>, ptr } %0, 0
  %2 = tail call i32 @llvm.riscv.esp.max.s8.a.m(<16 x i8> %1)
  ret i32 %2
}

declare i32 @llvm.riscv.esp.max.s8.a.m(<16 x i8>) #1

define dso_local i32 @test_min_s8(ptr noundef %src) local_unnamed_addr #0 {
; ASM-LABEL: test_min_s8:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    esp.vld.128.ip q0, a0, 16
; ASM-NEXT:    esp.min.s8.a q0, a0
; ASM-NEXT:    ret
entry:
  %0 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr %src, i32 16)
  %1 = extractvalue { <16 x i8>, ptr } %0, 0
  %2 = tail call i32 @llvm.riscv.esp.min.s8.a.m(<16 x i8> %1)
  ret i32 %2
}

declare i32 @llvm.riscv.esp.min.s8.a.m(<16 x i8>) #1

define dso_local i32 @test_max_u8(ptr noundef %src) local_unnamed_addr #0 {
; ASM-LABEL: test_max_u8:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    esp.vld.128.ip q0, a0, 16
; ASM-NEXT:    esp.max.u8.a q0, a0
; ASM-NEXT:    ret
entry:
  %0 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr %src, i32 16)
  %1 = extractvalue { <16 x i8>, ptr } %0, 0
  %2 = tail call i32 @llvm.riscv.esp.max.u8.a.m(<16 x i8> %1)
  ret i32 %2
}

declare i32 @llvm.riscv.esp.max.u8.a.m(<16 x i8>) #1

define dso_local i32 @test_min_u8(ptr noundef %src) local_unnamed_addr #0 {
; ASM-LABEL: test_min_u8:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    esp.vld.128.ip q0, a0, 16
; ASM-NEXT:    esp.min.u8.a q0, a0
; ASM-NEXT:    ret
entry:
  %0 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr %src, i32 16)
  %1 = extractvalue { <16 x i8>, ptr } %0, 0
  %2 = tail call i32 @llvm.riscv.esp.min.u8.a.m(<16 x i8> %1)
  ret i32 %2
}

declare i32 @llvm.riscv.esp.min.u8.a.m(<16 x i8>) #1

declare { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr, i32) #2

attributes #0 = { "target-features"="+32bit,+xespv" }
attributes #1 = { nounwind }
attributes #2 = { nounwind }


