; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; ModuleID = './riscv-esp32p4-movx-r-w-fft-bit-width.c'
; Test ASM generation (Intrinsic -> ASM)
; RUN: llc -O2 -mattr=xespv2p1 -mtriple=riscv32 %s -o - | FileCheck %s --check-prefix=ASM

define dso_local i32 @test_movx_fft_bit_width_write_read(i32 noundef %rs1_val) local_unnamed_addr #0 {
; ASM-LABEL: test_movx_fft_bit_width_write_read:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    esp.movx.w.fft.bit.width a0
; ASM-NEXT:    esp.movx.r.fft.bit.width a0
; ASM-NEXT:    ret
entry:
  %0 = tail call i32 @llvm.riscv.esp.movx.w.fft.bit.width.m(i32 %rs1_val)
  %1 = tail call i32 @llvm.riscv.esp.movx.r.fft.bit.width.m(i32 %0)
  ret i32 %1
}

declare i32 @llvm.riscv.esp.movx.w.fft.bit.width.m(i32) #1

declare i32 @llvm.riscv.esp.movx.r.fft.bit.width.m(i32) #1

define dso_local ptr @test_bitrev_with_fft_bit_width(ptr noundef %rs1, ptr noundef %dst, i32 noundef %bit_width) local_unnamed_addr #2 {
; ASM-LABEL: test_bitrev_with_fft_bit_width:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    esp.movx.w.fft.bit.width a2
; ASM-NEXT:    esp.fft.bitrev q0, a0
; ASM-NEXT:    mv a0, a1
; ASM-NEXT:    esp.vst.128.ip q0, a0, 16
; ASM-NEXT:    ret
entry:
  %0 = tail call i32 @llvm.riscv.esp.movx.w.fft.bit.width.m(i32 %bit_width)
  %1 = tail call { ptr, <8 x i16> } @llvm.riscv.esp.fft.bitrev.m(ptr %rs1, i32 %0)
  %2 = extractvalue { ptr, <8 x i16> } %1, 1
  %3 = bitcast <8 x i16> %2 to <16 x i8>
  %4 = tail call ptr @llvm.riscv.esp.vst.128.ip.m(<16 x i8> %3, ptr %dst, i32 16)
  %5 = tail call i32 @llvm.riscv.esp.movx.r.fft.bit.width.m(i32 %0)
  ret ptr %4
}

declare { ptr, <8 x i16> } @llvm.riscv.esp.fft.bitrev.m(ptr, i32) #1

declare ptr @llvm.riscv.esp.vst.128.ip.m(<16 x i8>, ptr, i32) #3

attributes #0 = { "target-features"="+32bit,+xespv" }
attributes #1 = { nounwind }
attributes #2 = { "target-features"="+32bit,+xespv" }
attributes #3 = { nounwind }


