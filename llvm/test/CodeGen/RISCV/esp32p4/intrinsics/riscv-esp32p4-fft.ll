; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; ModuleID = './riscv-esp32p4-fft.c'
; Test ASM generation (Intrinsic -> ASM)
; RUN: llc -O2 -mattr=xespv2p1 -mtriple=riscv32 %s -o - | FileCheck %s --check-prefix=ASM

define dso_local void @test_fft_r2bf_s16_m(ptr noundef %src1, ptr noundef %src2, ptr noundef %dst1, ptr noundef %dst2) local_unnamed_addr #0 {
; ASM-LABEL: test_fft_r2bf_s16_m:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    esp.vld.128.ip q0, a0, 16
; ASM-NEXT:    esp.vld.128.ip q1, a1, 16
; ASM-NEXT:    esp.fft.r2bf.s16 q0, q1, q0, q1, 0
; ASM-NEXT:    esp.vst.128.ip q0, a2, 16
; ASM-NEXT:    esp.vst.128.ip q1, a3, 16
; ASM-NEXT:    ret
entry:
  %vld1 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr %src1, i32 16)
  %ev1 = extractvalue { <16 x i8>, ptr } %vld1, 0
  %bc1 = bitcast <16 x i8> %ev1 to <8 x i16>
  %vld2 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr %src2, i32 16)
  %ev2 = extractvalue { <16 x i8>, ptr } %vld2, 0
  %bc2 = bitcast <16 x i8> %ev2 to <8 x i16>
  %v1 = tail call { <8 x i16>, <8 x i16> } @llvm.riscv.esp.fft.r2bf.s16.m(<8 x i16> %bc1, <8 x i16> %bc2, i32 0)
  %ev3 = extractvalue { <8 x i16>, <8 x i16> } %v1, 0
  %ev4 = extractvalue { <8 x i16>, <8 x i16> } %v1, 1
  %bc3 = bitcast <8 x i16> %ev3 to <16 x i8>
  %vst_ptr = tail call ptr @llvm.riscv.esp.vst.128.ip.m(<16 x i8> %bc3, ptr %dst1, i32 16)
  %bc4 = bitcast <8 x i16> %ev4 to <16 x i8>
  %vst_ptr.1 = tail call ptr @llvm.riscv.esp.vst.128.ip.m(<16 x i8> %bc4, ptr %dst2, i32 16)
  ret void
}

declare { <8 x i16>, <8 x i16> } @llvm.riscv.esp.fft.r2bf.s16.m(<8 x i16>, <8 x i16>, i32) #1

define dso_local void @test_fft_r2bf_s16_st_incp_m(ptr noundef %src1, ptr noundef %src2, ptr noundef %dst) local_unnamed_addr #0 {
; ASM-LABEL: test_fft_r2bf_s16_st_incp_m:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    esp.vld.128.ip q0, a0, 16
; ASM-NEXT:    esp.vld.128.ip q1, a1, 16
; ASM-NEXT:    esp.fft.r2bf.s16.st.incp q0, q0, q1, a2, 0
; ASM-NEXT:    ret
entry:
  %vld1 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr %src1, i32 16)
  %ev1 = extractvalue { <16 x i8>, ptr } %vld1, 0
  %bc1 = bitcast <16 x i8> %ev1 to <8 x i16>
  %vld2 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr %src2, i32 16)
  %ev2 = extractvalue { <16 x i8>, ptr } %vld2, 0
  %bc2 = bitcast <16 x i8> %ev2 to <8 x i16>
  %v1 = tail call { <8 x i16>, ptr } @llvm.riscv.esp.fft.r2bf.s16.st.incp.m(<8 x i16> %bc1, <8 x i16> %bc2, ptr %dst, i32 0)
  ret void
}

declare { <8 x i16>, ptr } @llvm.riscv.esp.fft.r2bf.s16.st.incp.m(<8 x i16>, <8 x i16>, ptr, i32) #2

define dso_local void @test_fft_ams_s16_ld_incp_m(ptr noundef %src, ptr noundef %dst) local_unnamed_addr #0 {
; ASM-LABEL: test_fft_ams_s16_ld_incp_m:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    mv a2, a0
; ASM-NEXT:    esp.vld.128.ip q0, a2, 16
; ASM-NEXT:    addi a2, a0, 16
; ASM-NEXT:    esp.vld.128.ip q1, a2, 16
; ASM-NEXT:    addi a2, a0, 32
; ASM-NEXT:    esp.vld.128.ip q2, a2, 16
; ASM-NEXT:    li a2, 0
; ASM-NEXT:    esp.movx.w.sar a2
; ASM-NEXT:    esp.fft.ams.s16.ld.incp q0, a0, q1, q2, q0, q2, q1, 0
; ASM-NEXT:    esp.vst.128.ip q0, a1, 16
; ASM-NEXT:    ret
entry:
  %sar = tail call i32 @llvm.riscv.esp.movx.w.sar.m(i32 0)
  %vld1 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr %src, i32 16)
  %ev1 = extractvalue { <16 x i8>, ptr } %vld1, 0
  %bc1 = bitcast <16 x i8> %ev1 to <8 x i16>
  %add.ptr = getelementptr inbounds nuw i8, ptr %src, i32 16
  %vld2 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr nonnull %add.ptr, i32 16)
  %ev2 = extractvalue { <16 x i8>, ptr } %vld2, 0
  %bc2 = bitcast <16 x i8> %ev2 to <8 x i16>
  %add.ptr1 = getelementptr inbounds nuw i8, ptr %src, i32 32
  %vld3 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr nonnull %add.ptr1, i32 16)
  %ev3 = extractvalue { <16 x i8>, ptr } %vld3, 0
  %bc3 = bitcast <16 x i8> %ev3 to <8 x i16>
  %v1 = tail call { <16 x i8>, <8 x i16>, <8 x i16>, ptr } @llvm.riscv.esp.fft.ams.s16.ld.incp.m(<8 x i16> %bc1, <8 x i16> %bc2, <8 x i16> %bc3, ptr %src, i32 0, i32 %sar)
  %ev4 = extractvalue { <16 x i8>, <8 x i16>, <8 x i16>, ptr } %v1, 0
  %vst_ptr = tail call ptr @llvm.riscv.esp.vst.128.ip.m(<16 x i8> %ev4, ptr %dst, i32 16)
  ret void
}

declare i32 @llvm.riscv.esp.movx.w.sar.m(i32) #1

declare { <16 x i8>, <8 x i16>, <8 x i16>, ptr } @llvm.riscv.esp.fft.ams.s16.ld.incp.m(<8 x i16>, <8 x i16>, <8 x i16>, ptr, i32, i32) #3

define dso_local void @test_fft_ams_s16_ld_r32_decp_m(ptr noundef %src, ptr noundef %dst) local_unnamed_addr #0 {
; ASM-LABEL: test_fft_ams_s16_ld_r32_decp_m:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    mv a2, a0
; ASM-NEXT:    esp.vld.128.ip q0, a2, 16
; ASM-NEXT:    addi a2, a0, 16
; ASM-NEXT:    esp.vld.128.ip q1, a2, 16
; ASM-NEXT:    addi a2, a0, 32
; ASM-NEXT:    esp.vld.128.ip q2, a2, 16
; ASM-NEXT:    li a2, 0
; ASM-NEXT:    esp.movx.w.sar a2
; ASM-NEXT:    esp.fft.ams.s16.ld.r32.decp q0, a0, q1, q2, q0, q2, q1, 0
; ASM-NEXT:    esp.vst.128.ip q0, a1, 16
; ASM-NEXT:    ret
entry:
  %sar = tail call i32 @llvm.riscv.esp.movx.w.sar.m(i32 0)
  %vld1 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr %src, i32 16)
  %ev1 = extractvalue { <16 x i8>, ptr } %vld1, 0
  %bc1 = bitcast <16 x i8> %ev1 to <8 x i16>
  %add.ptr = getelementptr inbounds nuw i8, ptr %src, i32 16
  %vld2 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr nonnull %add.ptr, i32 16)
  %ev2 = extractvalue { <16 x i8>, ptr } %vld2, 0
  %bc2 = bitcast <16 x i8> %ev2 to <8 x i16>
  %add.ptr1 = getelementptr inbounds nuw i8, ptr %src, i32 32
  %vld3 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr nonnull %add.ptr1, i32 16)
  %ev3 = extractvalue { <16 x i8>, ptr } %vld3, 0
  %bc3 = bitcast <16 x i8> %ev3 to <8 x i16>
  %v1 = tail call { <16 x i8>, <8 x i16>, <8 x i16>, ptr } @llvm.riscv.esp.fft.ams.s16.ld.r32.decp.m(<8 x i16> %bc1, <8 x i16> %bc2, <8 x i16> %bc3, ptr %src, i32 0, i32 %sar)
  %ev4 = extractvalue { <16 x i8>, <8 x i16>, <8 x i16>, ptr } %v1, 0
  %vst_ptr = tail call ptr @llvm.riscv.esp.vst.128.ip.m(<16 x i8> %ev4, ptr %dst, i32 16)
  ret void
}

declare { <16 x i8>, <8 x i16>, <8 x i16>, ptr } @llvm.riscv.esp.fft.ams.s16.ld.r32.decp.m(<8 x i16>, <8 x i16>, <8 x i16>, ptr, i32, i32) #3

define dso_local void @test_fft_ams_s16_st_incp_m(ptr noundef readonly captures(none) %0, ptr noundef readonly captures(none) %1, ptr noundef readonly captures(none) %2, ptr noundef readonly captures(none) %3, ptr noundef %dst, ptr noundef %rs2) local_unnamed_addr #0 {
; ASM-LABEL: test_fft_ams_s16_st_incp_m:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    esp.vld.128.ip q0, a0, 0
; ASM-NEXT:    esp.vld.128.ip q1, a1, 0
; ASM-NEXT:    esp.vld.128.ip q2, a2, 0
; ASM-NEXT:    esp.vld.128.ip q3, a3, 0
; ASM-NEXT:    li a0, 0
; ASM-NEXT:    esp.movx.w.sar a0
; ASM-NEXT:    esp.fft.ams.s16.st.incp q3, q0, a5, a4, q0, q2, q1, 0
; ASM-NEXT:    ret
entry:
  %qx = load <8 x i16>, ptr %0, align 16, !tbaa !36
  %qy = load <8 x i16>, ptr %1, align 16, !tbaa !36
  %qw = load <8 x i16>, ptr %2, align 16, !tbaa !36
  %qu = load <16 x i8>, ptr %3, align 16, !tbaa !36
  %sar = tail call i32 @llvm.riscv.esp.movx.w.sar.m(i32 0)
  %v1 = tail call { <8 x i16>, ptr } @llvm.riscv.esp.fft.ams.s16.st.incp.m(<8 x i16> %qx, <8 x i16> %qy, <8 x i16> %qw, <16 x i8> %qu, ptr %dst, ptr %rs2, i32 0, i32 %sar)
  ret void
}

declare { <8 x i16>, ptr } @llvm.riscv.esp.fft.ams.s16.st.incp.m(<8 x i16>, <8 x i16>, <8 x i16>, <16 x i8>, ptr, ptr, i32, i32) #2

define dso_local void @test_fft_bitrev_m(ptr noundef %rs1, ptr noundef %dst) local_unnamed_addr #4 {
; ASM-LABEL: test_fft_bitrev_m:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    li a2, 4
; ASM-NEXT:    esp.movx.w.fft.bit.width a2
; ASM-NEXT:    esp.fft.bitrev q0, a0
; ASM-NEXT:    esp.vst.128.ip q0, a1, 16
; ASM-NEXT:    ret
entry:
  %v1 = tail call { ptr, <8 x i16> } @llvm.riscv.esp.fft.bitrev.m(ptr %rs1, i32 4)
  %ev1 = extractvalue { ptr, <8 x i16> } %v1, 1
  %bc1 = bitcast <8 x i16> %ev1 to <16 x i8>
  %vst_ptr = tail call ptr @llvm.riscv.esp.vst.128.ip.m(<16 x i8> %bc1, ptr %dst, i32 16)
  ret void
}

declare { ptr, <8 x i16> } @llvm.riscv.esp.fft.bitrev.m(ptr, i32) #1

define dso_local void @test_fft_cmul_s16_ld_xp_m(ptr noundef %src, ptr noundef %rs2, ptr noundef %dst) local_unnamed_addr #0 {
; ASM-LABEL: test_fft_cmul_s16_ld_xp_m:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    mv a3, a0
; ASM-NEXT:    esp.vld.128.ip q0, a3, 16
; ASM-NEXT:    addi a3, a0, 16
; ASM-NEXT:    esp.vld.128.ip q1, a3, 16
; ASM-NEXT:    li a3, 0
; ASM-NEXT:    esp.movx.w.sar a3
; ASM-NEXT:    esp.fft.cmul.s16.ld.xp q1, a0, a1, q0, q1, q0, 0
; ASM-NEXT:    esp.vst.128.ip q1, a2, 16
; ASM-NEXT:    ret
entry:
  %sar = tail call i32 @llvm.riscv.esp.movx.w.sar.m(i32 0)
  %vld1 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr %src, i32 16)
  %ev1 = extractvalue { <16 x i8>, ptr } %vld1, 0
  %bc1 = bitcast <16 x i8> %ev1 to <8 x i16>
  %add.ptr = getelementptr inbounds nuw i8, ptr %src, i32 16
  %vld2 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr nonnull %add.ptr, i32 16)
  %ev2 = extractvalue { <16 x i8>, ptr } %vld2, 0
  %bc2 = bitcast <16 x i8> %ev2 to <8 x i16>
  %v1 = tail call { <8 x i16>, <16 x i8>, ptr } @llvm.riscv.esp.fft.cmul.s16.ld.xp.m(<8 x i16> %bc1, <8 x i16> %bc2, ptr %src, ptr %rs2, i32 0, i32 %sar)
  %ev3 = extractvalue { <8 x i16>, <16 x i8>, ptr } %v1, 1
  %vst_ptr = tail call ptr @llvm.riscv.esp.vst.128.ip.m(<16 x i8> %ev3, ptr %dst, i32 16)
  ret void
}

declare { <8 x i16>, <16 x i8>, ptr } @llvm.riscv.esp.fft.cmul.s16.ld.xp.m(<8 x i16>, <8 x i16>, ptr, ptr, i32, i32) #3

define dso_local void @test_fft_cmul_s16_st_xp_m(ptr noundef readonly captures(none) %0, ptr noundef readonly captures(none) %1, ptr noundef readonly captures(none) %2, ptr noundef %dst, ptr noundef %rs2) local_unnamed_addr #0 {
; ASM-LABEL: test_fft_cmul_s16_st_xp_m:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    esp.vld.128.ip q0, a0, 0
; ASM-NEXT:    esp.vld.128.ip q1, a1, 0
; ASM-NEXT:    esp.vld.128.ip q2, a2, 0
; ASM-NEXT:    li a0, 0
; ASM-NEXT:    esp.movx.w.sar a0
; ASM-NEXT:    esp.fft.cmul.s16.st.xp q1, q0, q2, a3, a4, 0, 0, 0
; ASM-NEXT:    ret
entry:
  %qx = load <8 x i16>, ptr %0, align 16, !tbaa !36
  %qy = load <8 x i16>, ptr %1, align 16, !tbaa !36
  %qu = load <16 x i8>, ptr %2, align 16, !tbaa !36
  %sar = tail call i32 @llvm.riscv.esp.movx.w.sar.m(i32 0)
  %v1 = tail call ptr @llvm.riscv.esp.fft.cmul.s16.st.xp.m(<8 x i16> %qx, <8 x i16> %qy, <16 x i8> %qu, ptr %dst, ptr %rs2, i32 0, i32 0, i32 0, i32 %sar)
  ret void
}

declare ptr @llvm.riscv.esp.fft.cmul.s16.st.xp.m(<8 x i16>, <8 x i16>, <16 x i8>, ptr, ptr, i32, i32, i32, i32) #2

define dso_local void @test_fft_vst_r32_decp_m(ptr noundef readonly captures(none) %0, ptr noundef %dst) local_unnamed_addr #0 {
; ASM-LABEL: test_fft_vst_r32_decp_m:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    esp.vld.128.ip q0, a0, 0
; ASM-NEXT:    esp.fft.vst.r32.decp q0, a1, 0
; ASM-NEXT:    ret
entry:
  %qu = load <16 x i8>, ptr %0, align 16, !tbaa !36
  %v1 = tail call ptr @llvm.riscv.esp.fft.vst.r32.decp.m(<16 x i8> %qu, ptr %dst, i32 0)
  ret void
}

declare ptr @llvm.riscv.esp.fft.vst.r32.decp.m(<16 x i8>, ptr, i32) #2

define dso_local void @test_fft_pipeline_complete_m(ptr noundef %src1, ptr noundef %src2, ptr noundef %dst1, ptr noundef %dst2) local_unnamed_addr #0 {
; ASM-LABEL: test_fft_pipeline_complete_m:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    esp.vld.128.ip q0, a0, 16
; ASM-NEXT:    esp.vld.128.ip q1, a1, 16
; ASM-NEXT:    esp.fft.r2bf.s16 q0, q1, q0, q1, 0
; ASM-NEXT:    esp.vst.128.ip q0, a2, 16
; ASM-NEXT:    esp.vst.128.ip q1, a3, 16
; ASM-NEXT:    ret
entry:
  %vld1 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr %src1, i32 16)
  %ev1 = extractvalue { <16 x i8>, ptr } %vld1, 0
  %bc1 = bitcast <16 x i8> %ev1 to <8 x i16>
  %vld2 = tail call { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr %src2, i32 16)
  %ev2 = extractvalue { <16 x i8>, ptr } %vld2, 0
  %bc2 = bitcast <16 x i8> %ev2 to <8 x i16>
  %v1 = tail call { <8 x i16>, <8 x i16> } @llvm.riscv.esp.fft.r2bf.s16.m(<8 x i16> %bc1, <8 x i16> %bc2, i32 0)
  %ev3 = extractvalue { <8 x i16>, <8 x i16> } %v1, 0
  %ev4 = extractvalue { <8 x i16>, <8 x i16> } %v1, 1
  %bc3 = bitcast <8 x i16> %ev3 to <16 x i8>
  %vst_ptr = tail call ptr @llvm.riscv.esp.vst.128.ip.m(<16 x i8> %bc3, ptr %dst1, i32 16)
  %bc4 = bitcast <8 x i16> %ev4 to <16 x i8>
  %vst_ptr.1 = tail call ptr @llvm.riscv.esp.vst.128.ip.m(<16 x i8> %bc4, ptr %dst2, i32 16)
  ret void
}

declare { <16 x i8>, ptr } @llvm.riscv.esp.vld.128.ip.m(ptr, i32) #3

declare ptr @llvm.riscv.esp.vst.128.ip.m(<16 x i8>, ptr, i32) #2

attributes #0 = { "target-features"="+32bit,+xespv" }
attributes #1 = { nounwind }
attributes #2 = { nounwind }
attributes #3 = { nounwind }
attributes #4 = { "target-features"="+32bit,+xespv" }


!36 = !{!37, !37, i64 0}
!37 = !{!"omnipotent char", !38, i64 0}
!38 = !{!"Simple C/C++ TBAA"}
