; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -mtriple=riscv32-esp-unknown-elf -passes=riscv-esp32p4-condition-split -riscv-esp32p4-condition-split=true < %s | FileCheck %s

target datalayout = "e-m:e-p:32:32-i64:64-n32-S128"
target triple = "riscv32-esp-unknown-elf"

define dso_local i32 @dspm_mult_s16_ansi(ptr noundef %A, ptr noundef %B, ptr noundef %C, i32 noundef %m, i32 noundef %n, i32 noundef %k, i32 noundef %shift) {
; CHECK-LABEL: define dso_local i32 @dspm_mult_s16_ansi(
; CHECK-SAME: ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], i32 noundef [[M:%.*]], i32 noundef [[N:%.*]], i32 noundef [[K:%.*]], i32 noundef [[SHIFT:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 4
; CHECK-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 4
; CHECK-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 4
; CHECK-NEXT:    [[M_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[N_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[K_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[SHIFT_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[FINAL_SHIFT:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[CLEANUP_DEST_SLOT:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[J:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[ACC:%.*]] = alloca i64, align 8
; CHECK-NEXT:    [[S:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 4
; CHECK-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 4
; CHECK-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 4
; CHECK-NEXT:    store i32 [[M]], ptr [[M_ADDR]], align 4
; CHECK-NEXT:    store i32 [[N]], ptr [[N_ADDR]], align 4
; CHECK-NEXT:    store i32 [[K]], ptr [[K_ADDR]], align 4
; CHECK-NEXT:    store i32 [[SHIFT]], ptr [[SHIFT_ADDR]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr [[FINAL_SHIFT]])
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[SHIFT_ADDR]], align 4
; CHECK-NEXT:    [[SUB:%.*]] = sub nsw i32 [[TMP0]], 15
; CHECK-NEXT:    store i32 [[SUB]], ptr [[FINAL_SHIFT]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr [[I]])
; CHECK-NEXT:    store i32 0, ptr [[I]], align 4
; CHECK-NEXT:    br label %[[FOR_COND:.*]]
; CHECK:       [[FOR_COND]]:
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[I]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[M_ADDR]], align 4
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    br i1 [[CMP]], label %[[FOR_BODY:.*]], label %[[FOR_COND_CLEANUP:.*]]
; CHECK:       [[FOR_COND_CLEANUP]]:
; CHECK-NEXT:    store i32 2, ptr [[CLEANUP_DEST_SLOT]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr [[I]])
; CHECK-NEXT:    br label %[[FOR_END36:.*]]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr [[J]])
; CHECK-NEXT:    store i32 0, ptr [[J]], align 4
; CHECK-NEXT:    br label %[[FOR_COND1:.*]]
; CHECK:       [[FOR_COND1]]:
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[J]], align 4
; CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[K_ADDR]], align 4
; CHECK-NEXT:    [[CMP2:%.*]] = icmp slt i32 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    br i1 [[CMP2]], label %[[FOR_BODY4:.*]], label %[[FOR_COND_CLEANUP3:.*]]
; CHECK:       [[FOR_COND_CLEANUP3]]:
; CHECK-NEXT:    store i32 5, ptr [[CLEANUP_DEST_SLOT]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr [[J]])
; CHECK-NEXT:    br label %[[FOR_END33:.*]]
; CHECK:       [[FOR_BODY4]]:
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[ACC]])
; CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr [[SHIFT_ADDR]], align 4
; CHECK-NEXT:    [[SHR:%.*]] = ashr i32 32767, [[TMP5]]
; CHECK-NEXT:    [[CONV:%.*]] = sext i32 [[SHR]] to i64
; CHECK-NEXT:    store i64 [[CONV]], ptr [[ACC]], align 8
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr [[S]])
; CHECK-NEXT:    store i32 0, ptr [[S]], align 4
; CHECK-NEXT:    br label %[[FOR_COND5:.*]]
; CHECK:       [[FOR_COND5]]:
; CHECK-NEXT:    [[TMP6:%.*]] = load i32, ptr [[S]], align 4
; CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[N_ADDR]], align 4
; CHECK-NEXT:    [[CMP6:%.*]] = icmp slt i32 [[TMP6]], [[TMP7]]
; CHECK-NEXT:    br i1 [[CMP6]], label %[[FOR_BODY9:.*]], label %[[FOR_COND_CLEANUP8:.*]]
; CHECK:       [[FOR_COND_CLEANUP8]]:
; CHECK-NEXT:    store i32 8, ptr [[CLEANUP_DEST_SLOT]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr [[S]])
; CHECK-NEXT:    br label %[[FOR_END:.*]]
; CHECK:       [[FOR_BODY9]]:
; CHECK-NEXT:    [[TMP8:%.*]] = load ptr, ptr [[A_ADDR]], align 4
; CHECK-NEXT:    [[TMP9:%.*]] = load i32, ptr [[I]], align 4
; CHECK-NEXT:    [[TMP10:%.*]] = load i32, ptr [[N_ADDR]], align 4
; CHECK-NEXT:    [[MUL:%.*]] = mul nsw i32 [[TMP9]], [[TMP10]]
; CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr [[S]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[MUL]], [[TMP11]]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i16, ptr [[TMP8]], i32 [[ADD]]
; CHECK-NEXT:    [[TMP12:%.*]] = load i16, ptr [[ARRAYIDX]], align 2
; CHECK-NEXT:    [[CONV10:%.*]] = sext i16 [[TMP12]] to i32
; CHECK-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[B_ADDR]], align 4
; CHECK-NEXT:    [[TMP14:%.*]] = load i32, ptr [[S]], align 4
; CHECK-NEXT:    [[TMP15:%.*]] = load i32, ptr [[K_ADDR]], align 4
; CHECK-NEXT:    [[MUL11:%.*]] = mul nsw i32 [[TMP14]], [[TMP15]]
; CHECK-NEXT:    [[TMP16:%.*]] = load i32, ptr [[J]], align 4
; CHECK-NEXT:    [[ADD12:%.*]] = add nsw i32 [[MUL11]], [[TMP16]]
; CHECK-NEXT:    [[ARRAYIDX13:%.*]] = getelementptr inbounds i16, ptr [[TMP13]], i32 [[ADD12]]
; CHECK-NEXT:    [[TMP17:%.*]] = load i16, ptr [[ARRAYIDX13]], align 2
; CHECK-NEXT:    [[CONV14:%.*]] = sext i16 [[TMP17]] to i32
; CHECK-NEXT:    [[MUL15:%.*]] = mul nsw i32 [[CONV10]], [[CONV14]]
; CHECK-NEXT:    [[CONV16:%.*]] = sext i32 [[MUL15]] to i64
; CHECK-NEXT:    [[TMP18:%.*]] = load i64, ptr [[ACC]], align 8
; CHECK-NEXT:    [[ADD17:%.*]] = add nsw i64 [[TMP18]], [[CONV16]]
; CHECK-NEXT:    store i64 [[ADD17]], ptr [[ACC]], align 8
; CHECK-NEXT:    br label %[[FOR_INC:.*]]
; CHECK:       [[FOR_INC]]:
; CHECK-NEXT:    [[TMP19:%.*]] = load i32, ptr [[S]], align 4
; CHECK-NEXT:    [[INC:%.*]] = add nsw i32 [[TMP19]], 1
; CHECK-NEXT:    store i32 [[INC]], ptr [[S]], align 4
; CHECK-NEXT:    br label %[[FOR_COND5]]
; CHECK:       [[FOR_END]]:
; CHECK-NEXT:    [[TMP20:%.*]] = load i32, ptr [[FINAL_SHIFT]], align 4
; CHECK-NEXT:    [[CMP18:%.*]] = icmp sgt i32 [[TMP20]], 0
; CHECK-NEXT:    br i1 [[CMP18]], label %[[IF_THEN:.*]], label %[[K_ALIGN_CHECK:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    [[TMP21:%.*]] = load i64, ptr [[ACC]], align 8
; CHECK-NEXT:    [[TMP22:%.*]] = load i32, ptr [[FINAL_SHIFT]], align 4
; CHECK-NEXT:    [[SH_PROM:%.*]] = zext i32 [[TMP22]] to i64
; CHECK-NEXT:    [[SHL:%.*]] = shl i64 [[TMP21]], [[SH_PROM]]
; CHECK-NEXT:    [[CONV20:%.*]] = trunc i64 [[SHL]] to i16
; CHECK-NEXT:    [[TMP23:%.*]] = load ptr, ptr [[C_ADDR]], align 4
; CHECK-NEXT:    [[TMP24:%.*]] = load i32, ptr [[I]], align 4
; CHECK-NEXT:    [[TMP25:%.*]] = load i32, ptr [[K_ADDR]], align 4
; CHECK-NEXT:    [[MUL21:%.*]] = mul nsw i32 [[TMP24]], [[TMP25]]
; CHECK-NEXT:    [[TMP26:%.*]] = load i32, ptr [[J]], align 4
; CHECK-NEXT:    [[ADD22:%.*]] = add nsw i32 [[MUL21]], [[TMP26]]
; CHECK-NEXT:    [[ARRAYIDX23:%.*]] = getelementptr inbounds i16, ptr [[TMP23]], i32 [[ADD22]]
; CHECK-NEXT:    store i16 [[CONV20]], ptr [[ARRAYIDX23]], align 2
; CHECK-NEXT:    br label %[[IF_END:.*]]
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[ACC]])
; CHECK-NEXT:    br label %[[FOR_INC31:.*]]
; CHECK:       [[FOR_INC31]]:
; CHECK-NEXT:    [[TMP27:%.*]] = load i32, ptr [[J]], align 4
; CHECK-NEXT:    [[INC32:%.*]] = add nsw i32 [[TMP27]], 1
; CHECK-NEXT:    store i32 [[INC32]], ptr [[J]], align 4
; CHECK-NEXT:    br label %[[FOR_COND1]]
; CHECK:       [[FOR_END33]]:
; CHECK-NEXT:    br label %[[FOR_INC34:.*]]
; CHECK:       [[FOR_INC34]]:
; CHECK-NEXT:    [[TMP28:%.*]] = load i32, ptr [[I]], align 4
; CHECK-NEXT:    [[INC35:%.*]] = add nsw i32 [[TMP28]], 1
; CHECK-NEXT:    store i32 [[INC35]], ptr [[I]], align 4
; CHECK-NEXT:    br label %[[FOR_COND]]
; CHECK:       [[FOR_END36]]:
; CHECK-NEXT:    store i32 1, ptr [[CLEANUP_DEST_SLOT]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr [[FINAL_SHIFT]])
; CHECK-NEXT:    ret i32 0
; CHECK:       [[K_ALIGN_CHECK]]:
; CHECK-NEXT:    [[K_VAL:%.*]] = load i32, ptr [[K_ADDR]], align 4
; CHECK-NEXT:    [[REM:%.*]] = srem i32 [[K_VAL]], 8
; CHECK-NEXT:    [[CMP22:%.*]] = icmp eq i32 [[REM]], 0
; CHECK-NEXT:    br i1 [[CMP22]], label %[[SIMD_PATH:.*]], label %[[SCALAR_PATH:.*]]
; CHECK:       [[SIMD_PATH]]:
; CHECK-NEXT:    [[TMP29:%.*]] = load i64, ptr [[ACC]], align 8
; CHECK-NEXT:    [[TMP30:%.*]] = load i32, ptr [[FINAL_SHIFT]], align 4
; CHECK-NEXT:    [[TMP31:%.*]] = sub nsw i32 0, [[TMP30]]
; CHECK-NEXT:    [[TMP32:%.*]] = zext i32 [[TMP31]] to i64
; CHECK-NEXT:    [[TMP33:%.*]] = ashr i64 [[TMP29]], [[TMP32]]
; CHECK-NEXT:    [[TMP34:%.*]] = trunc i64 [[TMP33]] to i16
; CHECK-NEXT:    [[TMP35:%.*]] = load ptr, ptr [[C_ADDR]], align 4
; CHECK-NEXT:    [[TMP36:%.*]] = load i32, ptr [[I]], align 4
; CHECK-NEXT:    [[TMP37:%.*]] = load i32, ptr [[K_ADDR]], align 4
; CHECK-NEXT:    [[TMP38:%.*]] = mul nsw i32 [[TMP36]], [[TMP37]]
; CHECK-NEXT:    [[TMP39:%.*]] = load i32, ptr [[J]], align 4
; CHECK-NEXT:    [[TMP40:%.*]] = add nsw i32 [[TMP38]], [[TMP39]]
; CHECK-NEXT:    [[TMP41:%.*]] = getelementptr inbounds i16, ptr [[TMP35]], i32 [[TMP40]]
; CHECK-NEXT:    store i16 [[TMP34]], ptr [[TMP41]], align 2
; CHECK-NEXT:    br label %[[SPLIT_MERGE:.*]]
; CHECK:       [[SCALAR_PATH]]:
; CHECK-NEXT:    [[TMP42:%.*]] = load i64, ptr [[ACC]], align 8
; CHECK-NEXT:    [[TMP43:%.*]] = load i32, ptr [[FINAL_SHIFT]], align 4
; CHECK-NEXT:    [[TMP44:%.*]] = sub nsw i32 0, [[TMP43]]
; CHECK-NEXT:    [[TMP45:%.*]] = zext i32 [[TMP44]] to i64
; CHECK-NEXT:    [[TMP46:%.*]] = ashr i64 [[TMP42]], [[TMP45]]
; CHECK-NEXT:    [[TMP47:%.*]] = trunc i64 [[TMP46]] to i16
; CHECK-NEXT:    [[TMP48:%.*]] = load ptr, ptr [[C_ADDR]], align 4
; CHECK-NEXT:    [[TMP49:%.*]] = load i32, ptr [[I]], align 4
; CHECK-NEXT:    [[TMP50:%.*]] = load i32, ptr [[K_ADDR]], align 4
; CHECK-NEXT:    [[TMP51:%.*]] = mul nsw i32 [[TMP49]], [[TMP50]]
; CHECK-NEXT:    [[TMP52:%.*]] = load i32, ptr [[J]], align 4
; CHECK-NEXT:    [[TMP53:%.*]] = add nsw i32 [[TMP51]], [[TMP52]]
; CHECK-NEXT:    [[TMP54:%.*]] = getelementptr inbounds i16, ptr [[TMP48]], i32 [[TMP53]]
; CHECK-NEXT:    store i16 [[TMP47]], ptr [[TMP54]], align 2
; CHECK-NEXT:    br label %[[SPLIT_MERGE]]
; CHECK:       [[SPLIT_MERGE]]:
; CHECK-NEXT:    br label %[[IF_END]]
;
entry:
  %A.addr = alloca ptr, align 4
  %B.addr = alloca ptr, align 4
  %C.addr = alloca ptr, align 4
  %m.addr = alloca i32, align 4
  %n.addr = alloca i32, align 4
  %k.addr = alloca i32, align 4
  %shift.addr = alloca i32, align 4
  %final_shift = alloca i32, align 4
  %i = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  %j = alloca i32, align 4
  %acc = alloca i64, align 8
  %s = alloca i32, align 4
  store ptr %A, ptr %A.addr, align 4
  store ptr %B, ptr %B.addr, align 4
  store ptr %C, ptr %C.addr, align 4
  store i32 %m, ptr %m.addr, align 4
  store i32 %n, ptr %n.addr, align 4
  store i32 %k, ptr %k.addr, align 4
  store i32 %shift, ptr %shift.addr, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %final_shift)
  %0 = load i32, ptr %shift.addr, align 4
  %sub = sub nsw i32 %0, 15
  store i32 %sub, ptr %final_shift, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %i)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc34, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %m.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  call void @llvm.lifetime.end.p0(i64 4, ptr %i)
  br label %for.end36

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 4, ptr %j)
  store i32 0, ptr %j, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc31, %for.body
  %3 = load i32, ptr %j, align 4
  %4 = load i32, ptr %k.addr, align 4
  %cmp2 = icmp slt i32 %3, %4
  br i1 %cmp2, label %for.body4, label %for.cond.cleanup3

for.cond.cleanup3:                                ; preds = %for.cond1
  store i32 5, ptr %cleanup.dest.slot, align 4
  call void @llvm.lifetime.end.p0(i64 4, ptr %j)
  br label %for.end33

for.body4:                                        ; preds = %for.cond1
  call void @llvm.lifetime.start.p0(i64 8, ptr %acc)
  %5 = load i32, ptr %shift.addr, align 4
  %shr = ashr i32 32767, %5
  %conv = sext i32 %shr to i64
  store i64 %conv, ptr %acc, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr %s)
  store i32 0, ptr %s, align 4
  br label %for.cond5

for.cond5:                                        ; preds = %for.inc, %for.body4
  %6 = load i32, ptr %s, align 4
  %7 = load i32, ptr %n.addr, align 4
  %cmp6 = icmp slt i32 %6, %7
  br i1 %cmp6, label %for.body9, label %for.cond.cleanup8

for.cond.cleanup8:                                ; preds = %for.cond5
  store i32 8, ptr %cleanup.dest.slot, align 4
  call void @llvm.lifetime.end.p0(i64 4, ptr %s)
  br label %for.end

for.body9:                                        ; preds = %for.cond5
  %8 = load ptr, ptr %A.addr, align 4
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %n.addr, align 4
  %mul = mul nsw i32 %9, %10
  %11 = load i32, ptr %s, align 4
  %add = add nsw i32 %mul, %11
  %arrayidx = getelementptr inbounds i16, ptr %8, i32 %add
  %12 = load i16, ptr %arrayidx, align 2
  %conv10 = sext i16 %12 to i32
  %13 = load ptr, ptr %B.addr, align 4
  %14 = load i32, ptr %s, align 4
  %15 = load i32, ptr %k.addr, align 4
  %mul11 = mul nsw i32 %14, %15
  %16 = load i32, ptr %j, align 4
  %add12 = add nsw i32 %mul11, %16
  %arrayidx13 = getelementptr inbounds i16, ptr %13, i32 %add12
  %17 = load i16, ptr %arrayidx13, align 2
  %conv14 = sext i16 %17 to i32
  %mul15 = mul nsw i32 %conv10, %conv14
  %conv16 = sext i32 %mul15 to i64
  %18 = load i64, ptr %acc, align 8
  %add17 = add nsw i64 %18, %conv16
  store i64 %add17, ptr %acc, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body9
  %19 = load i32, ptr %s, align 4
  %inc = add nsw i32 %19, 1
  store i32 %inc, ptr %s, align 4
  br label %for.cond5
for.end:                                          ; preds = %for.cond.cleanup8
  %20 = load i32, ptr %final_shift, align 4
  %cmp18 = icmp sgt i32 %20, 0
  br i1 %cmp18, label %if.then, label %if.else

if.then:                                          ; preds = %for.end
  %21 = load i64, ptr %acc, align 8
  %22 = load i32, ptr %final_shift, align 4
  %sh_prom = zext i32 %22 to i64
  %shl = shl i64 %21, %sh_prom
  %conv20 = trunc i64 %shl to i16
  %23 = load ptr, ptr %C.addr, align 4
  %24 = load i32, ptr %i, align 4
  %25 = load i32, ptr %k.addr, align 4
  %mul21 = mul nsw i32 %24, %25
  %26 = load i32, ptr %j, align 4
  %add22 = add nsw i32 %mul21, %26
  %arrayidx23 = getelementptr inbounds i16, ptr %23, i32 %add22
  store i16 %conv20, ptr %arrayidx23, align 2
  br label %if.end

if.else:                                          ; preds = %for.end
  %27 = load i64, ptr %acc, align 8
  %28 = load i32, ptr %final_shift, align 4
  %sub24 = sub nsw i32 0, %28
  %sh_prom25 = zext i32 %sub24 to i64
  %shr26 = ashr i64 %27, %sh_prom25
  %conv27 = trunc i64 %shr26 to i16
  %29 = load ptr, ptr %C.addr, align 4
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %k.addr, align 4
  %mul28 = mul nsw i32 %30, %31
  %32 = load i32, ptr %j, align 4
  %add29 = add nsw i32 %mul28, %32
  %arrayidx30 = getelementptr inbounds i16, ptr %29, i32 %add29
  store i16 %conv27, ptr %arrayidx30, align 2
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  call void @llvm.lifetime.end.p0(i64 8, ptr %acc)
  br label %for.inc31

for.inc31:                                        ; preds = %if.end
  %33 = load i32, ptr %j, align 4
  %inc32 = add nsw i32 %33, 1
  store i32 %inc32, ptr %j, align 4
  br label %for.cond1
for.end33:                                        ; preds = %for.cond.cleanup3
  br label %for.inc34

for.inc34:                                        ; preds = %for.end33
  %34 = load i32, ptr %i, align 4
  %inc35 = add nsw i32 %34, 1
  store i32 %inc35, ptr %i, align 4
  br label %for.cond
for.end36:                                        ; preds = %for.cond.cleanup
  store i32 1, ptr %cleanup.dest.slot, align 4
  call void @llvm.lifetime.end.p0(i64 4, ptr %final_shift)
  ret i32 0
}

declare void @llvm.lifetime.start.p0(i64 immarg %0, ptr nocapture %1)
declare void @llvm.lifetime.end.p0(i64 immarg %0, ptr nocapture %1)
