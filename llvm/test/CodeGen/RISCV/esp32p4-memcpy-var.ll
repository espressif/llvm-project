; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -mtriple=riscv32-esp-unknown-elf -passes=riscv-esp32-p4-mem-intrin -riscv-esp32-p4-mem-intrin=true < %s | FileCheck %s
target datalayout = "e-m:e-p:32:32-i64:64-n32-S128"
target triple = "riscv32-esp-unknown-elf"

define void @test_src16_dst16_variable_size(ptr %a, ptr %b, i32 %size) {
; CHECK-LABEL: define void @test_src16_dst16_variable_size(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i32 [[SIZE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i32
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[A]] to i32
; CHECK-NEXT:    call void @esp32p4MemCpySrc16dst16Var(i32 [[TMP1]], i32 [[TMP0]], i32 [[SIZE]])
; CHECK-NEXT:    ret void
;
entry:
  tail call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 16 %a, ptr noundef nonnull align 16 %b, i32 %size, i1 false)
  ret void
}

define void @test_src16_dst8_variable_size(ptr %a, ptr %b, i32 %size) {
; CHECK-LABEL: define void @test_src16_dst8_variable_size(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i32 [[SIZE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ult i32 [[SIZE]], 16
; CHECK-NEXT:    br i1 [[TMP0]], label %[[IF_SMALL:.*]], label %[[IF_LARGE:.*]]
; CHECK:       [[IF_SMALL]]:
; CHECK-NEXT:    call void @esp32p4MemCpySrcUnalignedDstUnalignedVarFrom0To15Opt(ptr [[A]], ptr [[B]], i32 [[SIZE]])
; CHECK-NEXT:    br label %[[CONTINUE:.*]]
; CHECK:       [[IF_LARGE]]:
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[B]] to i32
; CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i32
; CHECK-NEXT:    call void @esp32p4MemCpySrc16Dst8Var(i32 [[TMP2]], i32 [[TMP1]], i32 [[SIZE]])
; CHECK-NEXT:    br label %[[CONTINUE]]
; CHECK:       [[CONTINUE]]:
; CHECK-NEXT:    ret void
;
entry:
  tail call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 %a, ptr noundef nonnull align 16 %b, i32 %size, i1 false)
  ret void
}

define void @test_src8_dst16_variable_size(ptr %a, ptr %b, i32 %size) {
; CHECK-LABEL: define void @test_src8_dst16_variable_size(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i32 [[SIZE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ult i32 [[SIZE]], 16
; CHECK-NEXT:    br i1 [[TMP0]], label %[[IF_SMALL:.*]], label %[[IF_LARGE:.*]]
; CHECK:       [[IF_SMALL]]:
; CHECK-NEXT:    call void @esp32p4MemCpySrcUnalignedDstUnalignedVarFrom0To15Opt(ptr [[A]], ptr [[B]], i32 [[SIZE]])
; CHECK-NEXT:    br label %[[CONTINUE:.*]]
; CHECK:       [[IF_LARGE]]:
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[B]] to i32
; CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i32
; CHECK-NEXT:    call void @esp32p4MemCpySrc8Dst16Var(i32 [[TMP2]], i32 [[TMP1]], i32 [[SIZE]])
; CHECK-NEXT:    br label %[[CONTINUE]]
; CHECK:       [[CONTINUE]]:
; CHECK-NEXT:    ret void
;
entry:
  tail call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 16 %a, ptr noundef nonnull align 8 %b, i32 %size, i1 false)
  ret void
}

define void @test_src8_dst8_variable_size(ptr %a, ptr %b, i32 %size) {
; CHECK-LABEL: define void @test_src8_dst8_variable_size(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i32 [[SIZE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ult i32 [[SIZE]], 16
; CHECK-NEXT:    br i1 [[TMP0]], label %[[IF_SMALL:.*]], label %[[IF_LARGE:.*]]
; CHECK:       [[IF_SMALL]]:
; CHECK-NEXT:    call void @esp32p4MemCpySrcUnalignedDstUnalignedVarFrom0To15Opt(ptr [[A]], ptr [[B]], i32 [[SIZE]])
; CHECK-NEXT:    br label %[[CONTINUE:.*]]
; CHECK:       [[IF_LARGE]]:
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[B]] to i32
; CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i32
; CHECK-NEXT:    call void @esp32p4MemCpySrc8Dst8Var(i32 [[TMP2]], i32 [[TMP1]], i32 [[SIZE]])
; CHECK-NEXT:    br label %[[CONTINUE]]
; CHECK:       [[CONTINUE]]:
; CHECK-NEXT:    ret void
;
entry:
  tail call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 %a, ptr noundef nonnull align 8 %b, i32 %size, i1 false)
  ret void
}

; Function Attrs: noinline nounwind
define internal void @esp32p4MemCpySrc16dst16Var(i32 %0, i32 %1, i32 %2) {
; CHECK-LABEL: define internal void @esp32p4MemCpySrc16dst16Var(
; CHECK-SAME: i32 [[TMP0:%.*]], i32 [[TMP1:%.*]], i32 [[TMP2:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[TMP2]], 8
; CHECK-NEXT:    br i1 [[CMP]], label %[[IF_THEN:.*]], label %[[IF_ELSE:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    [[TMP3:%.*]] = inttoptr i32 [[TMP0]] to ptr
; CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i32 [[TMP1]] to ptr
; CHECK-NEXT:    call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr [[TMP3]], ptr [[TMP4]], i32 [[TMP2]])
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[IF_ELSE]]:
; CHECK-NEXT:    [[CMP1:%.*]] = icmp ult i32 [[TMP2]], 16
; CHECK-NEXT:    br i1 [[CMP1]], label %[[IF_THEN2:.*]], label %[[IF_END3:.*]]
; CHECK:       [[IF_THEN2]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i32 [[TMP0]] to ptr
; CHECK-NEXT:    [[TMP6:%.*]] = inttoptr i32 [[TMP1]] to ptr
; CHECK-NEXT:    [[SUB:%.*]] = add nsw i32 [[TMP2]], -8
; CHECK-NEXT:    call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr [[TMP5]], ptr [[TMP6]], i32 [[SUB]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[IF_END3]]:
; CHECK-NEXT:    [[DIV94:%.*]] = lshr i32 [[TMP2]], 7
; CHECK-NEXT:    [[REM:%.*]] = lshr i32 [[TMP2]], 4
; CHECK-NEXT:    [[DIV195:%.*]] = and i32 [[REM]], 7
; CHECK-NEXT:    [[REM4:%.*]] = and i32 [[TMP2]], 7
; CHECK-NEXT:    [[CMP97_NOT:%.*]] = icmp ult i32 [[TMP2]], 128
; CHECK-NEXT:    br i1 [[CMP97_NOT]], label %[[FOR_COND_CLEANUP:.*]], label %[[FOR_BODY:.*]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    ret void
; CHECK:       [[FOR_COND_CLEANUP]]:
; CHECK-NEXT:    switch i32 [[DIV195]], label %[[DEFAULT_UNREACHABLE:.*]] [
; CHECK-NEXT:      i32 1, label %[[SW_BB1:.*]]
; CHECK-NEXT:      i32 2, label %[[SW_BB2:.*]]
; CHECK-NEXT:      i32 3, label %[[SW_BB3:.*]]
; CHECK-NEXT:      i32 4, label %[[SW_BB4:.*]]
; CHECK-NEXT:      i32 5, label %[[SW_BB5:.*]]
; CHECK-NEXT:      i32 6, label %[[SW_BB6:.*]]
; CHECK-NEXT:      i32 7, label %[[SW_BB7:.*]]
; CHECK-NEXT:      i32 0, label %[[SW_EPILOG:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[I_098:%.*]] = phi i32 [ 0, %[[IF_END3]] ], [ [[INC:%.*]], %[[FOR_BODY]] ]
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q3, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q4, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q5, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q6, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q7, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q3, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q4, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q5, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q6, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q7, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_098]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i32 [[INC]], [[DIV94]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label %[[FOR_COND_CLEANUP]], label %[[FOR_BODY]]
; CHECK:       [[SW_EPILOG]]:
; CHECK-NEXT:    [[TMP7:%.*]] = and i32 [[TMP2]], 8
; CHECK-NEXT:    [[TMP8:%.*]] = icmp eq i32 [[TMP7]], 0
; CHECK-NEXT:    br i1 [[TMP8]], label %[[IF_END17:.*]], label %[[IF_THEN16:.*]]
; CHECK:       [[DEFAULT_UNREACHABLE]]:
; CHECK-NEXT:    unreachable
; CHECK:       [[SW_BB1]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB2]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB3]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB4]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q3, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q3, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB5]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q3, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q4, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q3, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q4, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB6]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q3, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q4, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q5, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q3, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q4, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q5, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB7]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q3, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q4, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q5, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q6, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q3, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q4, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q5, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q6, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[IF_THEN16]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[IF_END17]]
; CHECK:       [[IF_END17]]:
; CHECK-NEXT:    [[TMP9:%.*]] = icmp eq i32 [[REM4]], 0
; CHECK-NEXT:    br i1 [[TMP9]], label %[[RETURN]], label %[[IF_THEN13:.*]]
; CHECK:       [[IF_THEN13]]:
; CHECK-NEXT:    [[TMP10:%.*]] = inttoptr i32 [[TMP0]] to ptr
; CHECK-NEXT:    [[TMP11:%.*]] = inttoptr i32 [[TMP1]] to ptr
; CHECK-NEXT:    call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr [[TMP10]], ptr [[TMP11]], i32 [[REM4]])
; CHECK-NEXT:    br label %[[RETURN]]
;
entry:
  %cmp = icmp ult i32 %2, 8
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = inttoptr i32 %0 to ptr
  %4 = inttoptr i32 %1 to ptr
  call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr %3, ptr %4, i32 %2)
  br label %return

if.else:                                          ; preds = %entry
  %cmp1 = icmp ult i32 %2, 16
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.else
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  %5 = inttoptr i32 %0 to ptr
  %6 = inttoptr i32 %1 to ptr
  %sub = add nsw i32 %2, -8
  call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr %5, ptr %6, i32 %sub)
  br label %return

if.end3:                                          ; preds = %if.else
  %div94 = lshr i32 %2, 7
  %rem = lshr i32 %2, 4
  %div195 = and i32 %rem, 7
  %rem4 = and i32 %2, 7
  %cmp97.not = icmp ult i32 %2, 128
  br i1 %cmp97.not, label %for.cond.cleanup, label %for.body

return:                                           ; preds = %if.then13, %if.end17, %if.then2, %if.then
  ret void

for.cond.cleanup:                                 ; preds = %for.body, %if.end3
  switch i32 %div195, label %default.unreachable [
  i32 1, label %sw.bb1
  i32 2, label %sw.bb2
  i32 3, label %sw.bb3
  i32 4, label %sw.bb4
  i32 5, label %sw.bb5
  i32 6, label %sw.bb6
  i32 7, label %sw.bb7
  i32 0, label %sw.epilog
  ]

for.body:                                         ; preds = %for.body, %if.end3
  %i.098 = phi i32 [ 0, %if.end3 ], [ %inc, %for.body ]
  call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q3, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q4, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q5, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q6, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q7, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q3, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q4, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q5, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q6, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q7, $0, 16", "+{a0}"(i32 %0)
  %inc = add nuw nsw i32 %i.098, 1
  %exitcond.not = icmp eq i32 %inc, %div94
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body

sw.epilog:                                        ; preds = %for.cond.cleanup, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1
  %7 = and i32 %2, 8
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %if.end17, label %if.then16

default.unreachable:                              ; preds = %for.cond.cleanup
  unreachable

sw.bb1:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb2:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb3:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb4:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q3, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q3, $0, 16", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb5:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q3, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q4, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q3, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q4, $0, 16", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb6:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q3, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q4, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q5, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q3, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q4, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q5, $0, 16", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb7:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q3, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q4, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q5, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q6, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q3, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q4, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q5, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q6, $0, 16", "+{a0}"(i32 %0)
  br label %sw.epilog

if.then16:                                        ; preds = %sw.epilog
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %sw.epilog
  %9 = icmp eq i32 %rem4, 0
  br i1 %9, label %return, label %if.then13

if.then13:                                        ; preds = %if.end17
  %10 = inttoptr i32 %0 to ptr
  %11 = inttoptr i32 %1 to ptr
  call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr %10, ptr %11, i32 %rem4)
  br label %return
}

; Function Attrs: noinline nounwind
define internal void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr %0, ptr %1, i32 %2) {
; CHECK-LABEL: define internal void @esp32p4MemCpySrc16Dst16From0To15Opt(
; CHECK-SAME: ptr [[TMP0:%.*]], ptr [[TMP1:%.*]], i32 [[TMP2:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    switch i32 [[TMP2]], label %[[RETURN:.*]] [
; CHECK-NEXT:      i32 1, label %[[SW_BB0:.*]]
; CHECK-NEXT:      i32 2, label %[[SW_BB1:.*]]
; CHECK-NEXT:      i32 3, label %[[SW_BB2:.*]]
; CHECK-NEXT:      i32 4, label %[[SW_BB3:.*]]
; CHECK-NEXT:      i32 5, label %[[SW_BB4:.*]]
; CHECK-NEXT:      i32 6, label %[[SW_BB5:.*]]
; CHECK-NEXT:      i32 7, label %[[SW_BB6:.*]]
; CHECK-NEXT:      i32 8, label %[[SW_BB7:.*]]
; CHECK-NEXT:      i32 9, label %[[SW_BB8:.*]]
; CHECK-NEXT:      i32 10, label %[[SW_BB9:.*]]
; CHECK-NEXT:      i32 11, label %[[SW_BB10:.*]]
; CHECK-NEXT:      i32 12, label %[[SW_BB11:.*]]
; CHECK-NEXT:      i32 13, label %[[SW_BB12:.*]]
; CHECK-NEXT:      i32 14, label %[[SW_BB13:.*]]
; CHECK-NEXT:      i32 15, label %[[SW_BB14:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    ret void
; CHECK:       [[SW_BB0]]:
; CHECK-NEXT:    call void asm sideeffect "lb t0, 0($0)\0A\09sb t0, 0($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB1]]:
; CHECK-NEXT:    call void asm sideeffect "lh t0, 0($0)\0A\09sh t0, 0($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB2]]:
; CHECK-NEXT:    call void asm sideeffect "lh t0, 0($0)\0A\09sh t0, 0($1)\0A\09lb t0, 2($0)\0A\09sb t0, 2($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB3]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB4]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lb t0, 4($0)\0A\09sb t0, 4($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB5]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lh t0, 4($0)\0A\09sh t0, 4($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB6]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lh t0, 4($0)\0A\09sh t0, 4($1)\0A\09lb t0, 6($0)\0A\09sb t0, 6($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB7]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB8]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lb t0, 8($0)\0A\09sb t0, 8($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB9]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lh t0, 8($0)\0A\09sh t0, 8($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB10]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lh t0, 8($0)\0A\09sh t0, 8($1)\0A\09lb t0, 10($0)\0A\09sb t0, 10($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB11]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lw t0, 8($0)\0A\09sw t0, 8($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB12]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lw t0, 8($0)\0A\09sw t0, 8($1)\0A\09lb t0, 12($0)\0A\09sb t0, 12($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB13]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lw t0, 8($0)\0A\09sw t0, 8($1)\0A\09lh t0, 12($0)\0A\09sh t0, 12($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB14]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lw t0, 8($0)\0A\09sw t0, 8($1)\0A\09lh t0, 12($0)\0A\09sh t0, 12($1)\0A\09lb t0, 14($0)\0A\09sb t0, 14($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
;
entry:
  switch i32 %2, label %return [
  i32 1, label %sw.bb0
  i32 2, label %sw.bb1
  i32 3, label %sw.bb2
  i32 4, label %sw.bb3
  i32 5, label %sw.bb4
  i32 6, label %sw.bb5
  i32 7, label %sw.bb6
  i32 8, label %sw.bb7
  i32 9, label %sw.bb8
  i32 10, label %sw.bb9
  i32 11, label %sw.bb10
  i32 12, label %sw.bb11
  i32 13, label %sw.bb12
  i32 14, label %sw.bb13
  i32 15, label %sw.bb14
  ]

return:                                           ; preds = %sw.bb14, %sw.bb13, %sw.bb12, %sw.bb11, %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb0, %entry
  ret void

sw.bb0:                                           ; preds = %entry
  call void asm sideeffect "lb t0, 0($0)\0A\09sb t0, 0($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb1:                                           ; preds = %entry
  call void asm sideeffect "lh t0, 0($0)\0A\09sh t0, 0($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb2:                                           ; preds = %entry
  call void asm sideeffect "lh t0, 0($0)\0A\09sh t0, 0($1)\0A\09lb t0, 2($0)\0A\09sb t0, 2($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb3:                                           ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb4:                                           ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lb t0, 4($0)\0A\09sb t0, 4($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb5:                                           ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lh t0, 4($0)\0A\09sh t0, 4($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb6:                                           ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lh t0, 4($0)\0A\09sh t0, 4($1)\0A\09lb t0, 6($0)\0A\09sb t0, 6($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb7:                                           ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb8:                                           ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lb t0, 8($0)\0A\09sb t0, 8($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb9:                                           ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lh t0, 8($0)\0A\09sh t0, 8($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb10:                                          ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lh t0, 8($0)\0A\09sh t0, 8($1)\0A\09lb t0, 10($0)\0A\09sb t0, 10($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb11:                                          ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lw t0, 8($0)\0A\09sw t0, 8($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb12:                                          ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lw t0, 8($0)\0A\09sw t0, 8($1)\0A\09lb t0, 12($0)\0A\09sb t0, 12($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb13:                                          ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lw t0, 8($0)\0A\09sw t0, 8($1)\0A\09lh t0, 12($0)\0A\09sh t0, 12($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb14:                                          ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lw t0, 8($0)\0A\09sw t0, 8($1)\0A\09lh t0, 12($0)\0A\09sh t0, 12($1)\0A\09lb t0, 14($0)\0A\09sb t0, 14($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return
}

; Function Attrs: noinline nounwind
define internal void @esp32p4MemCpySrcUnalignedDstUnalignedVarFrom0To15Opt(ptr %0, ptr %1, i32 %2) {
; CHECK-LABEL: define internal void @esp32p4MemCpySrcUnalignedDstUnalignedVarFrom0To15Opt(
; CHECK-SAME: ptr [[TMP0:%.*]], ptr [[TMP1:%.*]], i32 [[TMP2:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    switch i32 [[TMP2]], label %[[RETURN:.*]] [
; CHECK-NEXT:      i32 1, label %[[SW_BB0:.*]]
; CHECK-NEXT:      i32 2, label %[[SW_BB1:.*]]
; CHECK-NEXT:      i32 3, label %[[SW_BB2:.*]]
; CHECK-NEXT:      i32 4, label %[[SW_BB3:.*]]
; CHECK-NEXT:      i32 5, label %[[SW_BB4:.*]]
; CHECK-NEXT:      i32 6, label %[[SW_BB5:.*]]
; CHECK-NEXT:      i32 7, label %[[SW_BB6:.*]]
; CHECK-NEXT:      i32 8, label %[[SW_BB7:.*]]
; CHECK-NEXT:      i32 9, label %[[SW_BB8:.*]]
; CHECK-NEXT:      i32 10, label %[[SW_BB9:.*]]
; CHECK-NEXT:      i32 11, label %[[SW_BB10:.*]]
; CHECK-NEXT:      i32 12, label %[[SW_BB11:.*]]
; CHECK-NEXT:      i32 13, label %[[SW_BB12:.*]]
; CHECK-NEXT:      i32 14, label %[[SW_BB13:.*]]
; CHECK-NEXT:      i32 15, label %[[SW_BB14:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    ret void
; CHECK:       [[SW_BB0]]:
; CHECK-NEXT:    call void asm sideeffect "lb t0, 0($0)\0A\09sb t0, 0($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB1]]:
; CHECK-NEXT:    call void asm sideeffect "lh t0, 0($0)\0A\09sh t0, 0($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB2]]:
; CHECK-NEXT:    call void asm sideeffect "lh t0, 0($0)\0A\09sh t0, 0($1)\0A\09lb t0, 2($0)\0A\09sb t0, 2($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB3]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB4]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lb t0, 4($0)\0A\09sb t0, 4($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB5]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lh t0, 4($0)\0A\09sh t0, 4($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB6]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lh t0, 4($0)\0A\09sh t0, 4($1)\0A\09lb t0, 6($0)\0A\09sb t0, 6($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB7]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB8]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lb t0, 8($0)\0A\09sb t0, 8($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB9]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lh t0, 8($0)\0A\09sh t0, 8($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB10]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lh t0, 8($0)\0A\09sh t0, 8($1)\0A\09lb t0, 10($0)\0A\09sb t0, 10($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB11]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lw t0, 8($0)\0A\09sw t0, 8($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB12]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lw t0, 8($0)\0A\09sw t0, 8($1)\0A\09lb t0, 12($0)\0A\09sb t0, 12($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB13]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lw t0, 8($0)\0A\09sw t0, 8($1)\0A\09lh t0, 12($0)\0A\09sh t0, 12($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[SW_BB14]]:
; CHECK-NEXT:    call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lw t0, 8($0)\0A\09sw t0, 8($1)\0A\09lh t0, 12($0)\0A\09sh t0, 12($1)\0A\09lb t0, 14($0)\0A\09sb t0, 14($1)\0A\09", "r,r,~{x5}"(ptr [[TMP1]], ptr [[TMP0]])
; CHECK-NEXT:    br label %[[RETURN]]
;
entry:
  switch i32 %2, label %return [
  i32 1, label %sw.bb0
  i32 2, label %sw.bb1
  i32 3, label %sw.bb2
  i32 4, label %sw.bb3
  i32 5, label %sw.bb4
  i32 6, label %sw.bb5
  i32 7, label %sw.bb6
  i32 8, label %sw.bb7
  i32 9, label %sw.bb8
  i32 10, label %sw.bb9
  i32 11, label %sw.bb10
  i32 12, label %sw.bb11
  i32 13, label %sw.bb12
  i32 14, label %sw.bb13
  i32 15, label %sw.bb14
  ]

return:                                           ; preds = %sw.bb14, %sw.bb13, %sw.bb12, %sw.bb11, %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb0, %entry
  ret void

sw.bb0:                                           ; preds = %entry
  call void asm sideeffect "lb t0, 0($0)\0A\09sb t0, 0($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb1:                                           ; preds = %entry
  call void asm sideeffect "lh t0, 0($0)\0A\09sh t0, 0($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb2:                                           ; preds = %entry
  call void asm sideeffect "lh t0, 0($0)\0A\09sh t0, 0($1)\0A\09lb t0, 2($0)\0A\09sb t0, 2($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb3:                                           ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb4:                                           ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lb t0, 4($0)\0A\09sb t0, 4($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb5:                                           ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lh t0, 4($0)\0A\09sh t0, 4($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb6:                                           ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lh t0, 4($0)\0A\09sh t0, 4($1)\0A\09lb t0, 6($0)\0A\09sb t0, 6($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb7:                                           ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb8:                                           ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lb t0, 8($0)\0A\09sb t0, 8($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb9:                                           ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lh t0, 8($0)\0A\09sh t0, 8($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb10:                                          ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lh t0, 8($0)\0A\09sh t0, 8($1)\0A\09lb t0, 10($0)\0A\09sb t0, 10($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb11:                                          ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lw t0, 8($0)\0A\09sw t0, 8($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb12:                                          ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lw t0, 8($0)\0A\09sw t0, 8($1)\0A\09lb t0, 12($0)\0A\09sb t0, 12($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb13:                                          ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lw t0, 8($0)\0A\09sw t0, 8($1)\0A\09lh t0, 12($0)\0A\09sh t0, 12($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return

sw.bb14:                                          ; preds = %entry
  call void asm sideeffect "lw t0, 0($0)\0A\09sw t0, 0($1)\0A\09lw t0, 4($0)\0A\09sw t0, 4($1)\0A\09lw t0, 8($0)\0A\09sw t0, 8($1)\0A\09lh t0, 12($0)\0A\09sh t0, 12($1)\0A\09lb t0, 14($0)\0A\09sb t0, 14($1)\0A\09", "r,r,~{x5}"(ptr %1, ptr %0)
  br label %return
}

; Function Attrs: noinline nounwind
define internal void @esp32p4MemCpySrc16Dst8Var(i32 %0, i32 %1, i32 %2) {
; CHECK-LABEL: define internal void @esp32p4MemCpySrc16Dst8Var(
; CHECK-SAME: i32 [[TMP0:%.*]], i32 [[TMP1:%.*]], i32 [[TMP2:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[TMP2]], 8
; CHECK-NEXT:    br i1 [[CMP]], label %[[IF_THEN:.*]], label %[[IF_END:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    [[TMP3:%.*]] = inttoptr i32 [[TMP0]] to ptr
; CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i32 [[TMP1]] to ptr
; CHECK-NEXT:    call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr [[TMP3]], ptr [[TMP4]], i32 [[TMP2]])
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    [[CMP1:%.*]] = icmp ult i32 [[TMP2]], 16
; CHECK-NEXT:    br i1 [[CMP1]], label %[[IF_THEN2:.*]], label %[[IF_END3:.*]]
; CHECK:       [[IF_THEN2]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i32 [[TMP0]] to ptr
; CHECK-NEXT:    [[TMP6:%.*]] = inttoptr i32 [[TMP1]] to ptr
; CHECK-NEXT:    [[SUB:%.*]] = add nsw i32 [[TMP2]], -8
; CHECK-NEXT:    call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr [[TMP5]], ptr [[TMP6]], i32 [[SUB]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[IF_END3]]:
; CHECK-NEXT:    [[CMP4:%.*]] = icmp ult i32 [[TMP2]], 32
; CHECK-NEXT:    br i1 [[CMP4]], label %[[IF_THEN5:.*]], label %[[IF_END7:.*]]
; CHECK:       [[IF_THEN5]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    [[TMP7:%.*]] = inttoptr i32 [[TMP0]] to ptr
; CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i32 [[TMP1]] to ptr
; CHECK-NEXT:    [[SUBM:%.*]] = add nsw i32 [[TMP2]], -16
; CHECK-NEXT:    call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr [[TMP7]], ptr [[TMP8]], i32 [[SUBM]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[IF_END7]]:
; CHECK-NEXT:    [[CMP8:%.*]] = icmp ult i32 [[TMP2]], 48
; CHECK-NEXT:    br i1 [[CMP8]], label %[[IF_THEN9:.*]], label %[[IF_END11:.*]]
; CHECK:       [[IF_THEN9]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    [[TMP9:%.*]] = inttoptr i32 [[TMP0]] to ptr
; CHECK-NEXT:    [[TMP10:%.*]] = inttoptr i32 [[TMP1]] to ptr
; CHECK-NEXT:    [[SUBM1:%.*]] = add nsw i32 [[TMP2]], -32
; CHECK-NEXT:    call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr [[TMP9]], ptr [[TMP10]], i32 [[SUBM1]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[IF_END11]]:
; CHECK-NEXT:    [[CMP12:%.*]] = icmp ult i32 [[TMP2]], 64
; CHECK-NEXT:    br i1 [[CMP12]], label %[[IF_THEN13:.*]], label %[[IF_END15:.*]]
; CHECK:       [[IF_THEN13]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    [[TMP11:%.*]] = inttoptr i32 [[TMP0]] to ptr
; CHECK-NEXT:    [[TMP12:%.*]] = inttoptr i32 [[TMP1]] to ptr
; CHECK-NEXT:    [[SUBM2:%.*]] = add nsw i32 [[TMP2]], -48
; CHECK-NEXT:    call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr [[TMP11]], ptr [[TMP12]], i32 [[SUBM2]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[IF_END15]]:
; CHECK-NEXT:    [[DIV94:%.*]] = lshr i32 [[TMP2]], 7
; CHECK-NEXT:    [[REM:%.*]] = lshr i32 [[TMP2]], 4
; CHECK-NEXT:    [[DIV195:%.*]] = and i32 [[REM]], 7
; CHECK-NEXT:    [[REM4:%.*]] = and i32 [[TMP2]], 7
; CHECK-NEXT:    [[CMP97_NOT:%.*]] = icmp ult i32 [[TMP2]], 128
; CHECK-NEXT:    br i1 [[CMP97_NOT]], label %[[FOR_COND_CLEANUP:.*]], label %[[FOR_BODY:.*]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    ret void
; CHECK:       [[FOR_COND_CLEANUP]]:
; CHECK-NEXT:    switch i32 [[DIV195]], label %[[DEFAULT_UNREACHABLE:.*]] [
; CHECK-NEXT:      i32 1, label %[[SW_BB1:.*]]
; CHECK-NEXT:      i32 2, label %[[SW_BB2:.*]]
; CHECK-NEXT:      i32 3, label %[[SW_BB3:.*]]
; CHECK-NEXT:      i32 4, label %[[SW_BB4:.*]]
; CHECK-NEXT:      i32 5, label %[[SW_BB5:.*]]
; CHECK-NEXT:      i32 6, label %[[SW_BB6:.*]]
; CHECK-NEXT:      i32 7, label %[[SW_BB7:.*]]
; CHECK-NEXT:      i32 0, label %[[SW_EPILOG:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[I_098:%.*]] = phi i32 [ 0, %[[IF_END15]] ], [ [[INC:%.*]], %[[FOR_BODY]] ]
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q3, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q4, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q5, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q6, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q7, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q3, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q3, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q4, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q4, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q5, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q5, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q6, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q6, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q7, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q7, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_098]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i32 [[INC]], [[DIV94]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label %[[FOR_COND_CLEANUP]], label %[[FOR_BODY]]
; CHECK:       [[SW_EPILOG]]:
; CHECK-NEXT:    [[TMP13:%.*]] = and i32 [[TMP2]], 8
; CHECK-NEXT:    [[TMP14:%.*]] = icmp eq i32 [[TMP13]], 0
; CHECK-NEXT:    br i1 [[TMP14]], label %[[IF_END17:.*]], label %[[IF_THEN16:.*]]
; CHECK:       [[DEFAULT_UNREACHABLE]]:
; CHECK-NEXT:    unreachable
; CHECK:       [[SW_BB1]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB2]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB3]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB4]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q3, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q3, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q3, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB5]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q3, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q4, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q3, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q3, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q4, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q4, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB6]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q3, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q4, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q5, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q3, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q3, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q4, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q4, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q5, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q5, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB7]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q3, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q4, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q5, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.128.ip q6, $0, 16", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q3, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q3, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q4, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q4, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q5, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q5, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q6, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q6, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[IF_THEN16]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[IF_END17]]
; CHECK:       [[IF_END17]]:
; CHECK-NEXT:    [[TMP15:%.*]] = icmp eq i32 [[REM4]], 0
; CHECK-NEXT:    br i1 [[TMP15]], label %[[RETURN]], label %[[IF_THEN31:.*]]
; CHECK:       [[IF_THEN31]]:
; CHECK-NEXT:    [[TMP16:%.*]] = inttoptr i32 [[TMP0]] to ptr
; CHECK-NEXT:    [[TMP17:%.*]] = inttoptr i32 [[TMP1]] to ptr
; CHECK-NEXT:    call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr [[TMP16]], ptr [[TMP17]], i32 [[REM4]])
; CHECK-NEXT:    br label %[[RETURN]]
;
entry:
  %cmp = icmp ult i32 %2, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = inttoptr i32 %0 to ptr
  %4 = inttoptr i32 %1 to ptr
  call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr %3, ptr %4, i32 %2)
  br label %return

if.end:                                           ; preds = %entry
  %cmp1 = icmp ult i32 %2, 16
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  %5 = inttoptr i32 %0 to ptr
  %6 = inttoptr i32 %1 to ptr
  %sub = add nsw i32 %2, -8
  call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr %5, ptr %6, i32 %sub)
  br label %return

if.end3:                                          ; preds = %if.end
  %cmp4 = icmp ult i32 %2, 32
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end3
  call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  %7 = inttoptr i32 %0 to ptr
  %8 = inttoptr i32 %1 to ptr
  %subm = add nsw i32 %2, -16
  call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr %7, ptr %8, i32 %subm)
  br label %return

if.end7:                                          ; preds = %if.end3
  %cmp8 = icmp ult i32 %2, 48
  br i1 %cmp8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end7
  call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  %9 = inttoptr i32 %0 to ptr
  %10 = inttoptr i32 %1 to ptr
  %subm1 = add nsw i32 %2, -32
  call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr %9, ptr %10, i32 %subm1)
  br label %return

if.end11:                                         ; preds = %if.end7
  %cmp12 = icmp ult i32 %2, 64
  br i1 %cmp12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end11
  call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  %11 = inttoptr i32 %0 to ptr
  %12 = inttoptr i32 %1 to ptr
  %subm2 = add nsw i32 %2, -48
  call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr %11, ptr %12, i32 %subm2)
  br label %return

if.end15:                                         ; preds = %if.end11
  %div94 = lshr i32 %2, 7
  %rem = lshr i32 %2, 4
  %div195 = and i32 %rem, 7
  %rem4 = and i32 %2, 7
  %cmp97.not = icmp ult i32 %2, 128
  br i1 %cmp97.not, label %for.cond.cleanup, label %for.body

return:                                           ; preds = %if.then31, %if.end17, %if.then13, %if.then9, %if.then5, %if.then2, %if.then
  ret void

for.cond.cleanup:                                 ; preds = %for.body, %if.end15
  switch i32 %div195, label %default.unreachable [
  i32 1, label %sw.bb1
  i32 2, label %sw.bb2
  i32 3, label %sw.bb3
  i32 4, label %sw.bb4
  i32 5, label %sw.bb5
  i32 6, label %sw.bb6
  i32 7, label %sw.bb7
  i32 0, label %sw.epilog
  ]

for.body:                                         ; preds = %for.body, %if.end15
  %i.098 = phi i32 [ 0, %if.end15 ], [ %inc, %for.body ]
  call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q3, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q4, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q5, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q6, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q7, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q3, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q3, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q4, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q4, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q5, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q5, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q6, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q6, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q7, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q7, $0, 8", "+{a0}"(i32 %0)
  %inc = add nuw nsw i32 %i.098, 1
  %exitcond.not = icmp eq i32 %inc, %div94
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body

sw.epilog:                                        ; preds = %for.cond.cleanup, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1
  %13 = and i32 %2, 8
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %if.end17, label %if.then16

default.unreachable:                              ; preds = %for.cond.cleanup
  unreachable

sw.bb1:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb2:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb3:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb4:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q3, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q3, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q3, $0, 8", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb5:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q3, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q4, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q3, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q3, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q4, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q4, $0, 8", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb6:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q3, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q4, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q5, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q3, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q3, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q4, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q4, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q5, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q5, $0, 8", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb7:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.128.ip q0, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q1, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q2, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q3, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q4, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q5, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.128.ip q6, $0, 16", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q3, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q3, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q4, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q4, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q5, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q5, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q6, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q6, $0, 8", "+{a0}"(i32 %0)
  br label %sw.epilog

if.then16:                                        ; preds = %sw.epilog
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %sw.epilog
  %15 = icmp eq i32 %rem4, 0
  br i1 %15, label %return, label %if.then31

if.then31:                                        ; preds = %if.end17
  %16 = inttoptr i32 %0 to ptr
  %17 = inttoptr i32 %1 to ptr
  call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr %16, ptr %17, i32 %rem4)
  br label %return
}

; Function Attrs: noinline nounwind
define internal void @esp32p4MemCpySrc8Dst16Var(i32 %0, i32 %1, i32 %2) {
; CHECK-LABEL: define internal void @esp32p4MemCpySrc8Dst16Var(
; CHECK-SAME: i32 [[TMP0:%.*]], i32 [[TMP1:%.*]], i32 [[TMP2:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[TMP2]], 8
; CHECK-NEXT:    br i1 [[CMP]], label %[[IF_THEN:.*]], label %[[IF_END:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    [[TMP3:%.*]] = inttoptr i32 [[TMP0]] to ptr
; CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i32 [[TMP1]] to ptr
; CHECK-NEXT:    call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr [[TMP3]], ptr [[TMP4]], i32 [[TMP2]])
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    [[CMP1:%.*]] = icmp ult i32 [[TMP2]], 16
; CHECK-NEXT:    br i1 [[CMP1]], label %[[IF_THEN2:.*]], label %[[IF_END3:.*]]
; CHECK:       [[IF_THEN2]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i32 [[TMP0]] to ptr
; CHECK-NEXT:    [[TMP6:%.*]] = inttoptr i32 [[TMP1]] to ptr
; CHECK-NEXT:    [[SUB:%.*]] = add nsw i32 [[TMP2]], -8
; CHECK-NEXT:    call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr [[TMP5]], ptr [[TMP6]], i32 [[SUB]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[IF_END3]]:
; CHECK-NEXT:    [[CMP4:%.*]] = icmp ult i32 [[TMP2]], 32
; CHECK-NEXT:    br i1 [[CMP4]], label %[[IF_THEN5:.*]], label %[[IF_END7:.*]]
; CHECK:       [[IF_THEN5]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    [[TMP7:%.*]] = inttoptr i32 [[TMP0]] to ptr
; CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i32 [[TMP1]] to ptr
; CHECK-NEXT:    [[SUBM:%.*]] = add nsw i32 [[TMP2]], -16
; CHECK-NEXT:    call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr [[TMP7]], ptr [[TMP8]], i32 [[SUBM]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[IF_END7]]:
; CHECK-NEXT:    [[CMP8:%.*]] = icmp ult i32 [[TMP2]], 48
; CHECK-NEXT:    br i1 [[CMP8]], label %[[IF_THEN9:.*]], label %[[IF_END11:.*]]
; CHECK:       [[IF_THEN9]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    [[TMP9:%.*]] = inttoptr i32 [[TMP0]] to ptr
; CHECK-NEXT:    [[TMP10:%.*]] = inttoptr i32 [[TMP1]] to ptr
; CHECK-NEXT:    [[SUBM1:%.*]] = add nsw i32 [[TMP2]], -32
; CHECK-NEXT:    call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr [[TMP9]], ptr [[TMP10]], i32 [[SUBM1]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[IF_END11]]:
; CHECK-NEXT:    [[CMP12:%.*]] = icmp ult i32 [[TMP2]], 64
; CHECK-NEXT:    br i1 [[CMP12]], label %[[IF_THEN13:.*]], label %[[IF_END15:.*]]
; CHECK:       [[IF_THEN13]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    [[TMP11:%.*]] = inttoptr i32 [[TMP0]] to ptr
; CHECK-NEXT:    [[TMP12:%.*]] = inttoptr i32 [[TMP1]] to ptr
; CHECK-NEXT:    [[SUBM2:%.*]] = add nsw i32 [[TMP2]], -48
; CHECK-NEXT:    call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr [[TMP11]], ptr [[TMP12]], i32 [[SUBM2]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[IF_END15]]:
; CHECK-NEXT:    [[DIV94:%.*]] = lshr i32 [[TMP2]], 7
; CHECK-NEXT:    [[REM:%.*]] = lshr i32 [[TMP2]], 4
; CHECK-NEXT:    [[DIV195:%.*]] = and i32 [[REM]], 7
; CHECK-NEXT:    [[REM4:%.*]] = and i32 [[TMP2]], 7
; CHECK-NEXT:    [[CMP97_NOT:%.*]] = icmp ult i32 [[TMP2]], 128
; CHECK-NEXT:    br i1 [[CMP97_NOT]], label %[[FOR_COND_CLEANUP:.*]], label %[[FOR_BODY:.*]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    ret void
; CHECK:       [[FOR_COND_CLEANUP]]:
; CHECK-NEXT:    switch i32 [[DIV195]], label %[[DEFAULT_UNREACHABLE:.*]] [
; CHECK-NEXT:      i32 1, label %[[SW_BB1:.*]]
; CHECK-NEXT:      i32 2, label %[[SW_BB2:.*]]
; CHECK-NEXT:      i32 3, label %[[SW_BB3:.*]]
; CHECK-NEXT:      i32 4, label %[[SW_BB4:.*]]
; CHECK-NEXT:      i32 5, label %[[SW_BB5:.*]]
; CHECK-NEXT:      i32 6, label %[[SW_BB6:.*]]
; CHECK-NEXT:      i32 7, label %[[SW_BB7:.*]]
; CHECK-NEXT:      i32 0, label %[[SW_EPILOG:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[I_098:%.*]] = phi i32 [ 0, %[[IF_END15]] ], [ [[INC:%.*]], %[[FOR_BODY]] ]
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q3, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q3, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q4, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q4, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q5, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q5, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q6, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q6, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q7, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q7, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q3, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q4, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q5, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q6, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q7, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_098]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i32 [[INC]], [[DIV94]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label %[[FOR_COND_CLEANUP]], label %[[FOR_BODY]]
; CHECK:       [[SW_EPILOG]]:
; CHECK-NEXT:    [[TMP13:%.*]] = and i32 [[TMP2]], 8
; CHECK-NEXT:    [[TMP14:%.*]] = icmp eq i32 [[TMP13]], 0
; CHECK-NEXT:    br i1 [[TMP14]], label %[[IF_END17:.*]], label %[[IF_THEN16:.*]]
; CHECK:       [[DEFAULT_UNREACHABLE]]:
; CHECK-NEXT:    unreachable
; CHECK:       [[SW_BB1]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB2]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB3]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB4]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q3, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q3, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q3, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB5]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q3, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q3, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q4, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q4, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q3, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q4, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB6]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q3, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q3, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q4, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q4, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q5, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q5, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q3, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q4, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q5, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB7]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q3, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q3, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q4, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q4, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q5, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q5, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q6, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q6, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q3, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q4, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q5, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q6, $0, 16", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[IF_THEN16]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[IF_END17]]
; CHECK:       [[IF_END17]]:
; CHECK-NEXT:    [[TMP15:%.*]] = icmp eq i32 [[REM4]], 0
; CHECK-NEXT:    br i1 [[TMP15]], label %[[RETURN]], label %[[IF_THEN31:.*]]
; CHECK:       [[IF_THEN31]]:
; CHECK-NEXT:    [[TMP16:%.*]] = inttoptr i32 [[TMP0]] to ptr
; CHECK-NEXT:    [[TMP17:%.*]] = inttoptr i32 [[TMP1]] to ptr
; CHECK-NEXT:    call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr [[TMP16]], ptr [[TMP17]], i32 [[REM4]])
; CHECK-NEXT:    br label %[[RETURN]]
;
entry:
  %cmp = icmp ult i32 %2, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = inttoptr i32 %0 to ptr
  %4 = inttoptr i32 %1 to ptr
  call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr %3, ptr %4, i32 %2)
  br label %return

if.end:                                           ; preds = %entry
  %cmp1 = icmp ult i32 %2, 16
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  %5 = inttoptr i32 %0 to ptr
  %6 = inttoptr i32 %1 to ptr
  %sub = add nsw i32 %2, -8
  call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr %5, ptr %6, i32 %sub)
  br label %return

if.end3:                                          ; preds = %if.end
  %cmp4 = icmp ult i32 %2, 32
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end3
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 %0)
  %7 = inttoptr i32 %0 to ptr
  %8 = inttoptr i32 %1 to ptr
  %subm = add nsw i32 %2, -16
  call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr %7, ptr %8, i32 %subm)
  br label %return

if.end7:                                          ; preds = %if.end3
  %cmp8 = icmp ult i32 %2, 48
  br i1 %cmp8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end7
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 %0)
  %9 = inttoptr i32 %0 to ptr
  %10 = inttoptr i32 %1 to ptr
  %subm1 = add nsw i32 %2, -32
  call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr %9, ptr %10, i32 %subm1)
  br label %return

if.end11:                                         ; preds = %if.end7
  %cmp12 = icmp ult i32 %2, 64
  br i1 %cmp12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end11
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 %0)
  %11 = inttoptr i32 %0 to ptr
  %12 = inttoptr i32 %1 to ptr
  %subm2 = add nsw i32 %2, -48
  call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr %11, ptr %12, i32 %subm2)
  br label %return

if.end15:                                         ; preds = %if.end11
  %div94 = lshr i32 %2, 7
  %rem = lshr i32 %2, 4
  %div195 = and i32 %rem, 7
  %rem4 = and i32 %2, 7
  %cmp97.not = icmp ult i32 %2, 128
  br i1 %cmp97.not, label %for.cond.cleanup, label %for.body

return:                                           ; preds = %if.then31, %if.end17, %if.then13, %if.then9, %if.then5, %if.then2, %if.then
  ret void

for.cond.cleanup:                                 ; preds = %for.body, %if.end15
  switch i32 %div195, label %default.unreachable [
  i32 1, label %sw.bb1
  i32 2, label %sw.bb2
  i32 3, label %sw.bb3
  i32 4, label %sw.bb4
  i32 5, label %sw.bb5
  i32 6, label %sw.bb6
  i32 7, label %sw.bb7
  i32 0, label %sw.epilog
  ]

for.body:                                         ; preds = %for.body, %if.end15
  %i.098 = phi i32 [ 0, %if.end15 ], [ %inc, %for.body ]
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q3, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q3, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q4, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q4, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q5, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q5, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q6, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q6, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q7, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q7, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q3, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q4, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q5, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q6, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q7, $0, 16", "+{a0}"(i32 %0)
  %inc = add nuw nsw i32 %i.098, 1
  %exitcond.not = icmp eq i32 %inc, %div94
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body

sw.epilog:                                        ; preds = %for.cond.cleanup, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1
  %13 = and i32 %2, 8
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %if.end17, label %if.then16

default.unreachable:                              ; preds = %for.cond.cleanup
  unreachable

sw.bb1:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb2:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb3:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb4:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q3, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q3, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q3, $0, 16", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb5:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q3, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q3, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q4, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q4, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q3, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q4, $0, 16", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb6:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q3, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q3, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q4, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q4, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q5, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q5, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q3, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q4, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q5, $0, 16", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb7:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q3, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q3, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q4, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q4, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q5, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q5, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q6, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q6, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q3, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q4, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q5, $0, 16", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.128.ip q6, $0, 16", "+{a0}"(i32 %0)
  br label %sw.epilog

if.then16:                                        ; preds = %sw.epilog
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %sw.epilog
  %15 = icmp eq i32 %rem4, 0
  br i1 %15, label %return, label %if.then31

if.then31:                                        ; preds = %if.end17
  %16 = inttoptr i32 %0 to ptr
  %17 = inttoptr i32 %1 to ptr
  call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr %16, ptr %17, i32 %rem4)
  br label %return
}

; Function Attrs: noinline nounwind
define internal void @esp32p4MemCpySrc8Dst8Var(i32 %0, i32 %1, i32 %2) {
; CHECK-LABEL: define internal void @esp32p4MemCpySrc8Dst8Var(
; CHECK-SAME: i32 [[TMP0:%.*]], i32 [[TMP1:%.*]], i32 [[TMP2:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[TMP2]], 8
; CHECK-NEXT:    br i1 [[CMP]], label %[[IF_THEN:.*]], label %[[IF_END:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    [[TMP3:%.*]] = inttoptr i32 [[TMP0]] to ptr
; CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i32 [[TMP1]] to ptr
; CHECK-NEXT:    call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr [[TMP3]], ptr [[TMP4]], i32 [[TMP2]])
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    [[CMP1:%.*]] = icmp ult i32 [[TMP2]], 16
; CHECK-NEXT:    br i1 [[CMP1]], label %[[IF_THEN2:.*]], label %[[IF_END3:.*]]
; CHECK:       [[IF_THEN2]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i32 [[TMP0]] to ptr
; CHECK-NEXT:    [[TMP6:%.*]] = inttoptr i32 [[TMP1]] to ptr
; CHECK-NEXT:    [[SUB:%.*]] = add nsw i32 [[TMP2]], -8
; CHECK-NEXT:    call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr [[TMP5]], ptr [[TMP6]], i32 [[SUB]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[IF_END3]]:
; CHECK-NEXT:    [[CMP4:%.*]] = icmp ult i32 [[TMP2]], 32
; CHECK-NEXT:    br i1 [[CMP4]], label %[[IF_THEN5:.*]], label %[[IF_END7:.*]]
; CHECK:       [[IF_THEN5]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    [[TMP7:%.*]] = inttoptr i32 [[TMP0]] to ptr
; CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i32 [[TMP1]] to ptr
; CHECK-NEXT:    [[SUBM:%.*]] = add nsw i32 [[TMP2]], -16
; CHECK-NEXT:    call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr [[TMP7]], ptr [[TMP8]], i32 [[SUBM]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[IF_END7]]:
; CHECK-NEXT:    [[CMP8:%.*]] = icmp ult i32 [[TMP2]], 48
; CHECK-NEXT:    br i1 [[CMP8]], label %[[IF_THEN9:.*]], label %[[IF_END11:.*]]
; CHECK:       [[IF_THEN9]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    [[TMP9:%.*]] = inttoptr i32 [[TMP0]] to ptr
; CHECK-NEXT:    [[TMP10:%.*]] = inttoptr i32 [[TMP1]] to ptr
; CHECK-NEXT:    [[SUBM1:%.*]] = add nsw i32 [[TMP2]], -32
; CHECK-NEXT:    call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr [[TMP9]], ptr [[TMP10]], i32 [[SUBM1]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[IF_END11]]:
; CHECK-NEXT:    [[CMP12:%.*]] = icmp ult i32 [[TMP2]], 64
; CHECK-NEXT:    br i1 [[CMP12]], label %[[IF_THEN13:.*]], label %[[IF_END15:.*]]
; CHECK:       [[IF_THEN13]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    [[TMP11:%.*]] = inttoptr i32 [[TMP0]] to ptr
; CHECK-NEXT:    [[TMP12:%.*]] = inttoptr i32 [[TMP1]] to ptr
; CHECK-NEXT:    [[SUBM2:%.*]] = add nsw i32 [[TMP2]], -48
; CHECK-NEXT:    call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr [[TMP11]], ptr [[TMP12]], i32 [[SUBM2]])
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[IF_END15]]:
; CHECK-NEXT:    [[DIV94:%.*]] = lshr i32 [[TMP2]], 7
; CHECK-NEXT:    [[REM:%.*]] = lshr i32 [[TMP2]], 4
; CHECK-NEXT:    [[DIV195:%.*]] = and i32 [[REM]], 7
; CHECK-NEXT:    [[REM4:%.*]] = and i32 [[TMP2]], 7
; CHECK-NEXT:    [[CMP97_NOT:%.*]] = icmp ult i32 [[TMP2]], 128
; CHECK-NEXT:    br i1 [[CMP97_NOT]], label %[[FOR_COND_CLEANUP:.*]], label %[[FOR_BODY:.*]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    ret void
; CHECK:       [[FOR_COND_CLEANUP]]:
; CHECK-NEXT:    switch i32 [[DIV195]], label %[[DEFAULT_UNREACHABLE:.*]] [
; CHECK-NEXT:      i32 1, label %[[SW_BB1:.*]]
; CHECK-NEXT:      i32 2, label %[[SW_BB2:.*]]
; CHECK-NEXT:      i32 3, label %[[SW_BB3:.*]]
; CHECK-NEXT:      i32 4, label %[[SW_BB4:.*]]
; CHECK-NEXT:      i32 5, label %[[SW_BB5:.*]]
; CHECK-NEXT:      i32 6, label %[[SW_BB6:.*]]
; CHECK-NEXT:      i32 7, label %[[SW_BB7:.*]]
; CHECK-NEXT:      i32 0, label %[[SW_EPILOG:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[I_098:%.*]] = phi i32 [ 0, %[[IF_END15]] ], [ [[INC:%.*]], %[[FOR_BODY]] ]
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q3, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q3, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q4, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q4, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q5, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q5, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q6, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q6, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q7, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q7, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q3, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q3, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q4, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q4, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q5, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q5, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q6, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q6, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q7, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q7, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_098]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i32 [[INC]], [[DIV94]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label %[[FOR_COND_CLEANUP]], label %[[FOR_BODY]]
; CHECK:       [[SW_EPILOG]]:
; CHECK-NEXT:    [[TMP13:%.*]] = and i32 [[TMP2]], 8
; CHECK-NEXT:    [[TMP14:%.*]] = icmp eq i32 [[TMP13]], 0
; CHECK-NEXT:    br i1 [[TMP14]], label %[[IF_END17:.*]], label %[[IF_THEN16:.*]]
; CHECK:       [[DEFAULT_UNREACHABLE]]:
; CHECK-NEXT:    unreachable
; CHECK:       [[SW_BB1]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB2]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB3]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB4]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q3, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q3, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q3, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q3, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB5]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q3, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q3, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q4, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q4, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q3, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q3, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q4, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q4, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB6]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q3, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q3, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q4, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q4, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q5, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q5, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q3, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q3, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q4, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q4, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q5, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q5, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[SW_BB7]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q3, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q3, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q4, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q4, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q5, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q5, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q6, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vld.h.64.ip q6, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q3, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q3, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q4, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q4, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q5, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q5, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q6, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.h.64.ip q6, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[SW_EPILOG]]
; CHECK:       [[IF_THEN16]]:
; CHECK-NEXT:    call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 [[TMP1]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 [[TMP0]])
; CHECK-NEXT:    br label %[[IF_END17]]
; CHECK:       [[IF_END17]]:
; CHECK-NEXT:    [[TMP15:%.*]] = icmp eq i32 [[REM4]], 0
; CHECK-NEXT:    br i1 [[TMP15]], label %[[RETURN]], label %[[IF_THEN31:.*]]
; CHECK:       [[IF_THEN31]]:
; CHECK-NEXT:    [[TMP16:%.*]] = inttoptr i32 [[TMP0]] to ptr
; CHECK-NEXT:    [[TMP17:%.*]] = inttoptr i32 [[TMP1]] to ptr
; CHECK-NEXT:    call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr [[TMP16]], ptr [[TMP17]], i32 [[REM4]])
; CHECK-NEXT:    br label %[[RETURN]]
;
entry:
  %cmp = icmp ult i32 %2, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = inttoptr i32 %0 to ptr
  %4 = inttoptr i32 %1 to ptr
  call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr %3, ptr %4, i32 %2)
  br label %return

if.end:                                           ; preds = %entry
  %cmp1 = icmp ult i32 %2, 16
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  %5 = inttoptr i32 %0 to ptr
  %6 = inttoptr i32 %1 to ptr
  %sub = add nsw i32 %2, -8
  call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr %5, ptr %6, i32 %sub)
  br label %return

if.end3:                                          ; preds = %if.end
  %cmp4 = icmp ult i32 %2, 32
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end3
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  %7 = inttoptr i32 %0 to ptr
  %8 = inttoptr i32 %1 to ptr
  %subm = add nsw i32 %2, -16
  call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr %7, ptr %8, i32 %subm)
  br label %return

if.end7:                                          ; preds = %if.end3
  %cmp8 = icmp ult i32 %2, 48
  br i1 %cmp8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end7
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  %9 = inttoptr i32 %0 to ptr
  %10 = inttoptr i32 %1 to ptr
  %subm1 = add nsw i32 %2, -32
  call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr %9, ptr %10, i32 %subm1)
  br label %return

if.end11:                                         ; preds = %if.end7
  %cmp12 = icmp ult i32 %2, 64
  br i1 %cmp12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end11
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  %11 = inttoptr i32 %0 to ptr
  %12 = inttoptr i32 %1 to ptr
  %subm2 = add nsw i32 %2, -48
  call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr %11, ptr %12, i32 %subm2)
  br label %return

if.end15:                                         ; preds = %if.end11
  %div94 = lshr i32 %2, 7
  %rem = lshr i32 %2, 4
  %div195 = and i32 %rem, 7
  %rem4 = and i32 %2, 7
  %cmp97.not = icmp ult i32 %2, 128
  br i1 %cmp97.not, label %for.cond.cleanup, label %for.body

return:                                           ; preds = %if.then31, %if.end17, %if.then13, %if.then9, %if.then5, %if.then2, %if.then
  ret void

for.cond.cleanup:                                 ; preds = %for.body, %if.end15
  switch i32 %div195, label %default.unreachable [
  i32 1, label %sw.bb1
  i32 2, label %sw.bb2
  i32 3, label %sw.bb3
  i32 4, label %sw.bb4
  i32 5, label %sw.bb5
  i32 6, label %sw.bb6
  i32 7, label %sw.bb7
  i32 0, label %sw.epilog
  ]

for.body:                                         ; preds = %for.body, %if.end15
  %i.098 = phi i32 [ 0, %if.end15 ], [ %inc, %for.body ]
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q3, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q3, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q4, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q4, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q5, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q5, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q6, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q6, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q7, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q7, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q3, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q3, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q4, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q4, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q5, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q5, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q6, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q6, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q7, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q7, $0, 8", "+{a0}"(i32 %0)
  %inc = add nuw nsw i32 %i.098, 1
  %exitcond.not = icmp eq i32 %inc, %div94
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body

sw.epilog:                                        ; preds = %for.cond.cleanup, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1
  %13 = and i32 %2, 8
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %if.end17, label %if.then16

default.unreachable:                              ; preds = %for.cond.cleanup
  unreachable

sw.bb1:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb2:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb3:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb4:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q3, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q3, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q3, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q3, $0, 8", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb5:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q3, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q3, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q4, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q4, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q3, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q3, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q4, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q4, $0, 8", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb6:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q3, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q3, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q4, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q4, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q5, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q5, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q3, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q3, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q4, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q4, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q5, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q5, $0, 8", "+{a0}"(i32 %0)
  br label %sw.epilog

sw.bb7:                                           ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q1, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q2, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q3, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q3, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q4, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q4, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q5, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q5, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.l.64.ip q6, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vld.h.64.ip q6, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q1, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q2, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q3, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q3, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q4, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q4, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q5, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q5, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.l.64.ip q6, $0, 8", "+{a0}"(i32 %0)
  call void asm sideeffect "esp.vst.h.64.ip q6, $0, 8", "+{a0}"(i32 %0)
  br label %sw.epilog

if.then16:                                        ; preds = %sw.epilog
  call void asm sideeffect "esp.vld.l.64.ip q0, $0, 8", "+{a1}"(i32 %1)
  call void asm sideeffect "esp.vst.l.64.ip q0, $0, 8", "+{a0}"(i32 %0)
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %sw.epilog
  %15 = icmp eq i32 %rem4, 0
  br i1 %15, label %return, label %if.then31

if.then31:                                        ; preds = %if.end17
  %16 = inttoptr i32 %0 to ptr
  %17 = inttoptr i32 %1 to ptr
  call void @esp32p4MemCpySrc16Dst16From0To15Opt(ptr %16, ptr %17, i32 %rem4)
  br label %return
}


define void @test_src16_dstunalign_variable_size(ptr %a, ptr %b, i32 %size) {
; CHECK-LABEL: define void @test_src16_dstunalign_variable_size(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i32 [[SIZE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ult i32 [[SIZE]], 16
; CHECK-NEXT:    br i1 [[TMP0]], label %[[IF_SMALL:.*]], label %[[IF_LARGE:.*]]
; CHECK:       [[IF_SMALL]]:
; CHECK-NEXT:    call void @esp32p4MemCpySrcUnalignedDstUnalignedVarFrom0To15Opt(ptr [[A]], ptr [[B]], i32 [[SIZE]])
; CHECK-NEXT:    br label %[[CONTINUE:.*]]
; CHECK:       [[IF_LARGE]]:
; CHECK-NEXT:    call void @esp32p4MemCpySrc16DstunalignedVar(ptr [[A]], ptr [[B]], i32 [[SIZE]], i32 1)
; CHECK-NEXT:    br label %[[CONTINUE]]
; CHECK:       [[CONTINUE]]:
; CHECK-NEXT:    ret void
;
entry:
  tail call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 1 %a, ptr noundef nonnull align 16 %b, i32 %size, i1 false)
  ret void
}

define void @test_src8_dstunalign_variable_size(ptr %a, ptr %b, i32 %size) {
; CHECK-LABEL: define void @test_src8_dstunalign_variable_size(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i32 [[SIZE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ult i32 [[SIZE]], 16
; CHECK-NEXT:    br i1 [[TMP0]], label %[[IF_SMALL:.*]], label %[[IF_LARGE:.*]]
; CHECK:       [[IF_SMALL]]:
; CHECK-NEXT:    call void @esp32p4MemCpySrcUnalignedDstUnalignedVarFrom0To15Opt(ptr [[A]], ptr [[B]], i32 [[SIZE]])
; CHECK-NEXT:    br label %[[CONTINUE:.*]]
; CHECK:       [[IF_LARGE]]:
; CHECK-NEXT:    call void @esp32p4MemCpySrc16DstunalignedVar(ptr [[A]], ptr [[B]], i32 [[SIZE]], i32 1)
; CHECK-NEXT:    br label %[[CONTINUE]]
; CHECK:       [[CONTINUE]]:
; CHECK-NEXT:    ret void
;
entry:
  tail call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 1 %a, ptr noundef nonnull align 8 %b, i32 %size, i1 false)
  ret void
}

define void @test_srcunalign_dst16_variable_size(ptr %a, ptr %b, i32 %size) {
; CHECK-LABEL: define void @test_srcunalign_dst16_variable_size(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i32 [[SIZE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ult i32 [[SIZE]], 16
; CHECK-NEXT:    br i1 [[TMP0]], label %[[IF_SMALL:.*]], label %[[IF_LARGE:.*]]
; CHECK:       [[IF_SMALL]]:
; CHECK-NEXT:    call void @esp32p4MemCpySrcUnalignedDstUnalignedVarFrom0To15Opt(ptr [[A]], ptr [[B]], i32 [[SIZE]])
; CHECK-NEXT:    br label %[[CONTINUE:.*]]
; CHECK:       [[IF_LARGE]]:
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[B]] to i32
; CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i32
; CHECK-NEXT:    call void @esp32p4MemCpySrcunalignedDst16Var(i32 [[TMP2]], i32 [[TMP1]], i32 [[SIZE]])
; CHECK-NEXT:    br label %[[CONTINUE]]
; CHECK:       [[CONTINUE]]:
; CHECK-NEXT:    ret void
;
entry:
  tail call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 16 %a, ptr noundef nonnull align 1 %b, i32 %size, i1 false)
  ret void
}

define void @test_srcunalign_dst8_variable_size(ptr %a, ptr %b, i32 %size) {
; CHECK-LABEL: define void @test_srcunalign_dst8_variable_size(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i32 [[SIZE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ult i32 [[SIZE]], 16
; CHECK-NEXT:    br i1 [[TMP0]], label %[[IF_SMALL:.*]], label %[[IF_END_I:.*]]
; CHECK:       [[IF_SMALL]]:
; CHECK-NEXT:    call void @esp32p4MemCpySrcUnalignedDstUnalignedVarFrom0To15Opt(ptr [[A]], ptr [[B]], i32 [[SIZE]])
; CHECK-NEXT:    br label %[[CONTINUE:.*]]
; CHECK:       [[IF_END_I]]:
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[B]], align 1
; CHECK-NEXT:    store i64 [[TMP1]], ptr [[A]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = add i32 [[SIZE]], -8
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[A]], i32 8
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[B]], i32 8
; CHECK-NEXT:    [[TMP5:%.*]] = ptrtoint ptr [[TMP4]] to i32
; CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[TMP3]] to i32
; CHECK-NEXT:    call void @esp32p4MemCpySrcunalignedDst16Var(i32 [[TMP6]], i32 [[TMP5]], i32 [[TMP2]])
; CHECK-NEXT:    br label %[[CONTINUE]]
; CHECK:       [[CONTINUE]]:
; CHECK-NEXT:    ret void
;
entry:
  tail call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 %a, ptr noundef nonnull align 1 %b, i32 %size, i1 false)
  ret void
}

define void @test_srcunalign1_dstunalign1_variable_size(ptr %a, ptr %b, i32 %size) {
; CHECK-LABEL: define void @test_srcunalign1_dstunalign1_variable_size(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i32 [[SIZE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ult i32 [[SIZE]], 16
; CHECK-NEXT:    br i1 [[TMP0]], label %[[IF_SMALL:.*]], label %[[IF_LARGE:.*]]
; CHECK:       [[IF_SMALL]]:
; CHECK-NEXT:    call void @esp32p4MemCpySrcUnalignedDstUnalignedVarFrom0To15Opt(ptr [[A]], ptr [[B]], i32 [[SIZE]])
; CHECK-NEXT:    br label %[[CONTINUE:.*]]
; CHECK:       [[IF_LARGE]]:
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[B]] to i32
; CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i32
; CHECK-NEXT:    call void @esp32p4MemCpySrcunalignedDst16Var(i32 [[TMP2]], i32 [[TMP1]], i32 [[SIZE]])
; CHECK-NEXT:    br label %[[CONTINUE]]
; CHECK:       [[CONTINUE]]:
; CHECK-NEXT:    ret void
;
entry:
  tail call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 1 %a, ptr noundef nonnull align 1 %b, i32 %size, i1 false)
  ret void
}

define void @test_srcunalign2_dstunalign2_variable_size(ptr %a, ptr %b, i32 %size) {
; CHECK-LABEL: define void @test_srcunalign2_dstunalign2_variable_size(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i32 [[SIZE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ult i32 [[SIZE]], 16
; CHECK-NEXT:    br i1 [[TMP0]], label %[[IF_SMALL:.*]], label %[[IF_LARGE:.*]]
; CHECK:       [[IF_SMALL]]:
; CHECK-NEXT:    call void @esp32p4MemCpySrcUnalignedDstUnalignedVarFrom0To15Opt(ptr [[A]], ptr [[B]], i32 [[SIZE]])
; CHECK-NEXT:    br label %[[CONTINUE:.*]]
; CHECK:       [[IF_LARGE]]:
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[B]] to i32
; CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i32
; CHECK-NEXT:    call void @esp32p4MemCpySrcunalignedDst16Var(i32 [[TMP2]], i32 [[TMP1]], i32 [[SIZE]])
; CHECK-NEXT:    br label %[[CONTINUE]]
; CHECK:       [[CONTINUE]]:
; CHECK-NEXT:    ret void
;
entry:
  tail call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 2 %a, ptr noundef nonnull align 2 %b, i32 %size, i1 false)
  ret void
}

define void @test_srcunalign1_dstunalign2_variable_size(ptr %a, ptr %b, i32 %size) {
; CHECK-LABEL: define void @test_srcunalign1_dstunalign2_variable_size(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i32 [[SIZE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ult i32 [[SIZE]], 16
; CHECK-NEXT:    br i1 [[TMP0]], label %[[IF_SMALL:.*]], label %[[IF_LARGE:.*]]
; CHECK:       [[IF_SMALL]]:
; CHECK-NEXT:    call void @esp32p4MemCpySrcUnalignedDstUnalignedVarFrom0To15Opt(ptr [[A]], ptr [[B]], i32 [[SIZE]])
; CHECK-NEXT:    br label %[[CONTINUE:.*]]
; CHECK:       [[IF_LARGE]]:
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[B]] to i32
; CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i32
; CHECK-NEXT:    call void @esp32p4MemCpySrcunalignedDst16Var(i32 [[TMP2]], i32 [[TMP1]], i32 [[SIZE]])
; CHECK-NEXT:    br label %[[CONTINUE]]
; CHECK:       [[CONTINUE]]:
; CHECK-NEXT:    ret void
;
entry:
  tail call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 1 %a, ptr noundef nonnull align 2 %b, i32 %size, i1 false)
  ret void
}

define void @test_srcunalign2_dstunalign1_variable_size(ptr %a, ptr %b, i32 %size) {
; CHECK-LABEL: define void @test_srcunalign2_dstunalign1_variable_size(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i32 [[SIZE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ult i32 [[SIZE]], 16
; CHECK-NEXT:    br i1 [[TMP0]], label %[[IF_SMALL:.*]], label %[[IF_LARGE:.*]]
; CHECK:       [[IF_SMALL]]:
; CHECK-NEXT:    call void @esp32p4MemCpySrcUnalignedDstUnalignedVarFrom0To15Opt(ptr [[A]], ptr [[B]], i32 [[SIZE]])
; CHECK-NEXT:    br label %[[CONTINUE:.*]]
; CHECK:       [[IF_LARGE]]:
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[B]] to i32
; CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i32
; CHECK-NEXT:    call void @esp32p4MemCpySrcunalignedDst16Var(i32 [[TMP2]], i32 [[TMP1]], i32 [[SIZE]])
; CHECK-NEXT:    br label %[[CONTINUE]]
; CHECK:       [[CONTINUE]]:
; CHECK-NEXT:    ret void
;
entry:
  tail call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 2 %a, ptr noundef nonnull align 1 %b, i32 %size, i1 false)
  ret void
}

; Function Attrs: noinline nounwind
define internal void @esp32p4MemCpySrcunalignedDst16Var(i32 %dst, i32 %src, i32 %size) {
; CHECK-LABEL: define internal void @esp32p4MemCpySrcunalignedDst16Var(
; CHECK-SAME: i32 [[DST:%.*]], i32 [[SRC:%.*]], i32 [[SIZE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[SIZE]], 16
; CHECK-NEXT:    br i1 [[CMP]], label %[[CLEANUP_OUT:.*]], label %[[IF_END:.*]]
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    [[DIV:%.*]] = udiv i32 [[SIZE]], 48
; CHECK-NEXT:    [[TMP0:%.*]] = mul i32 [[DIV]], 48
; CHECK-NEXT:    [[REM_DECOMPOSED:%.*]] = sub i32 [[SIZE]], [[TMP0]]
; CHECK-NEXT:    call void asm sideeffect "esp.ld.128.usar.ip q0, $0, 16", "+{a1}"(i32 [[SRC]])
; CHECK-NEXT:    call void asm sideeffect "esp.ld.128.usar.ip q1, $0, 16", "+{a1}"(i32 [[SRC]])
; CHECK-NEXT:    [[CMP21_NOT:%.*]] = icmp ult i32 [[SIZE]], 48
; CHECK-NEXT:    br i1 [[CMP21_NOT]], label %[[FOR_COND_CLEANUP:.*]], label %[[FOR_BODY:.*]]
; CHECK:       [[FOR_COND_CLEANUP]]:
; CHECK-NEXT:    [[TOBOOL_NOT:%.*]] = icmp ult i32 [[REM_DECOMPOSED]], 32
; CHECK-NEXT:    br i1 [[TOBOOL_NOT]], label %[[IF_END3:.*]], label %[[IF_THEN2:.*]]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[I_022:%.*]] = phi i32 [ 0, %[[IF_END]] ], [ [[INC:%.*]], %[[FOR_BODY]] ]
; CHECK-NEXT:    call void asm sideeffect "esp.src.q.ld.ip q2, $0, 16, q0, q1", "+{a1}"(i32 [[SRC]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 [[DST]])
; CHECK-NEXT:    call void asm sideeffect "esp.src.q.ld.ip q0, $0, 16, q1, q2", "+{a1}"(i32 [[SRC]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 [[DST]])
; CHECK-NEXT:    call void asm sideeffect "esp.src.q.ld.ip q1, $0, 16, q2, q0", "+{a1}"(i32 [[SRC]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 [[DST]])
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_022]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i32 [[INC]], [[DIV]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label %[[FOR_COND_CLEANUP]], label %[[FOR_BODY]]
; CHECK:       [[IF_THEN2]]:
; CHECK-NEXT:    call void asm sideeffect "esp.src.q.ld.ip q2, $0, 0, q0, q1", "+{a1}"(i32 [[SRC]])
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 [[DST]])
; CHECK-NEXT:    call void asm sideeffect "esp.src.q q1, q1, q2", ""()
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 [[DST]])
; CHECK-NEXT:    [[SUB1:%.*]] = add nsw i32 [[REM_DECOMPOSED]], -32
; CHECK-NEXT:    br label %[[CLEANUP_OUT]]
; CHECK:       [[IF_END3]]:
; CHECK-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp ult i32 [[REM_DECOMPOSED]], 16
; CHECK-NEXT:    br i1 [[TOBOOL5_NOT]], label %[[IF_END7:.*]], label %[[IF_THEN6:.*]]
; CHECK:       [[IF_THEN6]]:
; CHECK-NEXT:    call void asm sideeffect "esp.src.q q0, q0, q1", ""()
; CHECK-NEXT:    call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 [[DST]])
; CHECK-NEXT:    [[SUB:%.*]] = add i32 [[SRC]], -16
; CHECK-NEXT:    [[SUB9:%.*]] = add nsw i32 [[REM_DECOMPOSED]], -16
; CHECK-NEXT:    br label %[[CLEANUP_OUT]]
; CHECK:       [[IF_END7]]:
; CHECK-NEXT:    [[SUB8:%.*]] = add nsw i32 [[SRC]], -32
; CHECK-NEXT:    br label %[[CLEANUP_OUT]]
; CHECK:       [[CLEANUP_OUT]]:
; CHECK-NEXT:    [[SRC_SINK:%.*]] = phi i32 [ [[SRC]], %[[IF_THEN2]] ], [ [[SUB]], %[[IF_THEN6]] ], [ [[SRC]], %[[ENTRY]] ], [ [[SUB8]], %[[IF_END7]] ]
; CHECK-NEXT:    [[REM_SINK:%.*]] = phi i32 [ [[SIZE]], %[[ENTRY]] ], [ [[SUB1]], %[[IF_THEN2]] ], [ [[SUB9]], %[[IF_THEN6]] ], [ [[REM_DECOMPOSED]], %[[IF_END7]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = inttoptr i32 [[DST]] to ptr
; CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i32 [[SRC_SINK]] to ptr
; CHECK-NEXT:    call void @esp32p4MemCpySrcUnalignedDstUnalignedVarFrom0To15Opt(ptr [[TMP1]], ptr [[TMP2]], i32 [[REM_SINK]])
; CHECK-NEXT:    ret void
;
entry:
  %cmp = icmp ult i32 %size, 16
  br i1 %cmp, label %cleanup.out, label %if.end

if.end:                                           ; preds = %entry
  %div = udiv i32 %size, 48
  %0 = mul i32 %div, 48
  %rem.decomposed = sub i32 %size, %0
  call void asm sideeffect "esp.ld.128.usar.ip q0, $0, 16", "+{a1}"(i32 %src)
  call void asm sideeffect "esp.ld.128.usar.ip q1, $0, 16", "+{a1}"(i32 %src)
  %cmp21.not = icmp ult i32 %size, 48
  br i1 %cmp21.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:                                 ; preds = %for.body, %if.end
  %tobool.not = icmp ult i32 %rem.decomposed, 32
  br i1 %tobool.not, label %if.end3, label %if.then2

for.body:                                         ; preds = %for.body, %if.end
  %i.022 = phi i32 [ 0, %if.end ], [ %inc, %for.body ]
  call void asm sideeffect "esp.src.q.ld.ip q2, $0, 16, q0, q1", "+{a1}"(i32 %src)
  call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 %dst)
  call void asm sideeffect "esp.src.q.ld.ip q0, $0, 16, q1, q2", "+{a1}"(i32 %src)
  call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 %dst)
  call void asm sideeffect "esp.src.q.ld.ip q1, $0, 16, q2, q0", "+{a1}"(i32 %src)
  call void asm sideeffect "esp.vst.128.ip q2, $0, 16", "+{a0}"(i32 %dst)
  %inc = add nuw nsw i32 %i.022, 1
  %exitcond.not = icmp eq i32 %inc, %div
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body

if.then2:                                         ; preds = %for.cond.cleanup
  call void asm sideeffect "esp.src.q.ld.ip q2, $0, 0, q0, q1", "+{a1}"(i32 %src)
  call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 %dst)
  call void asm sideeffect "esp.src.q q1, q1, q2", ""()
  call void asm sideeffect "esp.vst.128.ip q1, $0, 16", "+{a0}"(i32 %dst)
  %sub1 = add nsw i32 %rem.decomposed, -32
  br label %cleanup.out

if.end3:                                          ; preds = %for.cond.cleanup
  %tobool5.not = icmp ult i32 %rem.decomposed, 16
  br i1 %tobool5.not, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end3
  call void asm sideeffect "esp.src.q q0, q0, q1", ""()
  call void asm sideeffect "esp.vst.128.ip q0, $0, 16", "+{a0}"(i32 %dst)
  %sub = add i32 %src, -16
  %sub9 = add nsw i32 %rem.decomposed, -16
  br label %cleanup.out

if.end7:                                          ; preds = %if.end3
  %sub8 = add nsw i32 %src, -32
  br label %cleanup.out

cleanup.out:                                      ; preds = %if.end7, %if.then6, %if.then2, %entry
  %src.sink = phi i32 [ %src, %if.then2 ], [ %sub, %if.then6 ], [ %src, %entry ], [ %sub8, %if.end7 ]
  %rem.sink = phi i32 [ %size, %entry ], [ %sub1, %if.then2 ], [ %sub9, %if.then6 ], [ %rem.decomposed, %if.end7 ]
  %1 = inttoptr i32 %dst to ptr
  %2 = inttoptr i32 %src.sink to ptr
  call void @esp32p4MemCpySrcUnalignedDstUnalignedVarFrom0To15Opt(ptr %1, ptr %2, i32 %rem.sink)
  ret void
}

; Function Attrs: noinline nounwind
define internal void @esp32p4MemCpySrc16DstunalignedVar(ptr %dst, ptr %src, i32 %size, i32 %dst_align) #12 {
; CHECK-LABEL: define internal void @esp32p4MemCpySrc16DstunalignedVar(
; CHECK-SAME: ptr [[DST:%.*]], ptr [[SRC:%.*]], i32 [[SIZE:%.*]], i32 [[DST_ALIGN:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SUB:%.*]] = sub i32 16, [[DST_ALIGN]]
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp ult i32 [[SUB]], [[SIZE]]
; CHECK-NEXT:    br i1 [[CMP_NOT]], label %[[IF_END:.*]], label %[[IF_THEN:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    call void @esp32p4MemCpySrcUnalignedDstUnalignedVarFrom0To15Opt(ptr [[DST]], ptr [[SRC]], i32 [[SIZE]])
; CHECK-NEXT:    br label %[[CLEANUP:.*]]
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    call void @esp32p4MemCpySrcUnalignedDstUnalignedVarFrom0To15Opt(ptr [[DST]], ptr [[SRC]], i32 [[SUB]])
; CHECK-NEXT:    [[SUB2:%.*]] = sub i32 [[SIZE]], [[SUB]]
; CHECK-NEXT:    [[ADD_PTR1:%.*]] = getelementptr i8, ptr [[DST]], i32 [[SUB]]
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr i8, ptr [[SRC]], i32 [[SUB]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ult i32 [[SUB2]], 16
; CHECK-NEXT:    br i1 [[TMP0]], label %[[IF_SMALL:.*]], label %[[IF_LARGE:.*]]
; CHECK:       [[IF_SMALL]]:
; CHECK-NEXT:    call void @esp32p4MemCpySrcUnalignedDstUnalignedVarFrom0To15Opt(ptr [[ADD_PTR1]], ptr [[ADD_PTR]], i32 [[SUB2]])
; CHECK-NEXT:    br label %[[CLEANUP]]
; CHECK:       [[IF_LARGE]]:
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[ADD_PTR]] to i32
; CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[ADD_PTR1]] to i32
; CHECK-NEXT:    call void @esp32p4MemCpySrcunalignedDst16Var(i32 [[TMP2]], i32 [[TMP1]], i32 [[SUB2]])
; CHECK-NEXT:    br label %[[CLEANUP]]
; CHECK:       [[CLEANUP]]:
; CHECK-NEXT:    ret void
;
entry:
  %sub = sub i32 16, %dst_align
  %cmp.not = icmp ult i32 %sub, %size
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @esp32p4MemCpySrcUnalignedDstUnalignedVarFrom0To15Opt(ptr %dst, ptr %src, i32 %size)
  br label %cleanup

if.end:                                           ; preds = %entry
  call void @esp32p4MemCpySrcUnalignedDstUnalignedVarFrom0To15Opt(ptr %dst, ptr %src, i32 %sub)
  %sub2 = sub i32 %size, %sub
  %add.ptr1 = getelementptr i8, ptr %dst, i32 %sub
  %add.ptr = getelementptr i8, ptr %src, i32 %sub
  %0 = icmp ult i32 %sub2, 16
  br i1 %0, label %if.small, label %if.large

if.small:                                         ; preds = %if.end
  call void @esp32p4MemCpySrcUnalignedDstUnalignedVarFrom0To15Opt(ptr %add.ptr1, ptr %add.ptr, i32 %sub2)
  br label %cleanup

if.large:                                         ; preds = %if.end
  %1 = ptrtoint ptr %add.ptr to i32
  %2 = ptrtoint ptr %add.ptr1 to i32
  call void @esp32p4MemCpySrcunalignedDst16Var(i32 %2, i32 %1, i32 %sub2)
  br label %cleanup

cleanup:                                          ; preds = %if.small, %if.large, %if.then
  ret void
}

declare void @llvm.memcpy.p0.p0.i32(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i32, i1 immarg)

