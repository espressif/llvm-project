; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt -S -mtriple=riscv32-esp-unknown-elf -passes=riscv-loop-unroll-and-remainder -riscv-loop-unroll-and-remainder=false < %s | FileCheck %s
define dso_local float @test_loop(ptr nocapture noundef readonly %data1, ptr nocapture noundef readonly %data2, i32 noundef %start_index, i32 noundef %end_index, i32 noundef %update1, i32 noundef %update2, float noundef %offset) local_unnamed_addr {
; CHECK-LABEL: define dso_local float @test_loop(
; CHECK-SAME: ptr nocapture noundef readonly [[DATA1:%.*]], ptr nocapture noundef readonly [[DATA2:%.*]], i32 noundef [[START_INDEX:%.*]], i32 noundef [[END_INDEX:%.*]], i32 noundef [[UPDATE1:%.*]], i32 noundef [[UPDATE2:%.*]], float noundef [[OFFSET:%.*]]) local_unnamed_addr {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[INVARIANT_GEP:%.*]] = getelementptr float, ptr [[DATA1]], i32 [[UPDATE1]]
; CHECK-NEXT:    [[INVARIANT_GEP8:%.*]] = getelementptr float, ptr [[DATA2]], i32 [[UPDATE2]]
; CHECK-NEXT:    [[CMP10:%.*]] = icmp slt i32 [[START_INDEX]], [[END_INDEX]]
; CHECK-NEXT:    br i1 [[CMP10]], label [[FOR_BODY:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    [[RESULT_0_LCSSA:%.*]] = phi float [ 0.000000e+00, [[ENTRY:%.*]] ], [ [[ADD3:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    ret float [[RESULT_0_LCSSA]]
; CHECK:       for.body:
; CHECK-NEXT:    [[I_012:%.*]] = phi i32 [ [[INC:%.*]], [[FOR_BODY]] ], [ [[START_INDEX]], [[ENTRY]] ]
; CHECK-NEXT:    [[RESULT_011:%.*]] = phi float [ [[ADD3]], [[FOR_BODY]] ], [ 0.000000e+00, [[ENTRY]] ]
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr float, ptr [[INVARIANT_GEP]], i32 [[I_012]]
; CHECK-NEXT:    [[TMP0:%.*]] = load float, ptr [[GEP]], align 4
; CHECK-NEXT:    [[GEP9:%.*]] = getelementptr float, ptr [[INVARIANT_GEP8]], i32 [[I_012]]
; CHECK-NEXT:    [[TMP1:%.*]] = load float, ptr [[GEP9]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = tail call float @llvm.fmuladd.f32(float [[TMP0]], float [[TMP1]], float [[OFFSET]])
; CHECK-NEXT:    [[ADD3]] = fadd float [[RESULT_011]], [[TMP2]]
; CHECK-NEXT:    [[INC]] = add nsw i32 [[I_012]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i32 [[INC]], [[END_INDEX]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY]]
;
entry:
  %invariant.gep = getelementptr float, ptr %data1, i32 %update1
  %invariant.gep8 = getelementptr float, ptr %data2, i32 %update2
  %cmp10 = icmp slt i32 %start_index, %end_index
  br i1 %cmp10, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %result.0.lcssa = phi float [ 0.000000e+00, %entry ], [ %add3, %for.body ]
  ret float %result.0.lcssa

for.body:                                         ; preds = %for.body, %entry
  %i.012 = phi i32 [ %inc, %for.body ], [ %start_index, %entry ]
  %result.011 = phi float [ %add3, %for.body ], [ 0.000000e+00, %entry ]
  %gep = getelementptr float, ptr %invariant.gep, i32 %i.012
  %0 = load float, ptr %gep, align 4
  %gep9 = getelementptr float, ptr %invariant.gep8, i32 %i.012
  %1 = load float, ptr %gep9, align 4
  %2 = tail call float @llvm.fmuladd.f32(float %0, float %1, float %offset)
  %add3 = fadd float %result.011, %2
  %inc = add nsw i32 %i.012, 1
  %exitcond.not = icmp eq i32 %inc, %end_index
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}
