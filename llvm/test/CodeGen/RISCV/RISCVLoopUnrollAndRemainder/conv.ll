; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt -S -mtriple=riscv32-esp-unknown-elf -passes=riscv-loop-unroll-and-remainder -riscv-loop-unroll-and-remainder=false < %s | FileCheck %s
define dso_local noundef i32 @dsps_conv_f32_ansi(ptr noundef readonly %Signal, i32 noundef %siglen, ptr noundef readonly %Kernel, i32 noundef %kernlen, ptr noundef writeonly %convout) local_unnamed_addr {
; CHECK-LABEL: define dso_local noundef i32 @dsps_conv_f32_ansi(
; CHECK-SAME: ptr noundef readonly [[SIGNAL:%.*]], i32 noundef [[SIGLEN:%.*]], ptr noundef readonly [[KERNEL:%.*]], i32 noundef [[KERNLEN:%.*]], ptr noundef writeonly [[CONVOUT:%.*]]) local_unnamed_addr {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq ptr [[SIGNAL]], null
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq ptr [[KERNEL]], null
; CHECK-NEXT:    [[OR_COND:%.*]] = or i1 [[CMP]], [[CMP1]]
; CHECK-NEXT:    [[CMP4:%.*]] = icmp eq ptr [[CONVOUT]], null
; CHECK-NEXT:    [[OR_COND118:%.*]] = or i1 [[OR_COND]], [[CMP4]]
; CHECK-NEXT:    br i1 [[OR_COND118]], label [[RETURN:%.*]], label [[IF_END6:%.*]]
; CHECK:       if.end6:
; CHECK-NEXT:    [[CMP7:%.*]] = icmp slt i32 [[SIGLEN]], [[KERNLEN]]
; CHECK-NEXT:    br i1 [[CMP7]], label [[IF_THEN8:%.*]], label [[IF_END9:%.*]]
; CHECK:       if.then8:
; CHECK-NEXT:    br label [[IF_END9]]
; CHECK:       if.end9:
; CHECK-NEXT:    [[LKERN_0:%.*]] = phi i32 [ [[SIGLEN]], [[IF_THEN8]] ], [ [[KERNLEN]], [[IF_END6]] ]
; CHECK-NEXT:    [[LSIG_0:%.*]] = phi i32 [ [[KERNLEN]], [[IF_THEN8]] ], [ [[SIGLEN]], [[IF_END6]] ]
; CHECK-NEXT:    [[KERN_0:%.*]] = phi ptr [ [[SIGNAL]], [[IF_THEN8]] ], [ [[KERNEL]], [[IF_END6]] ]
; CHECK-NEXT:    [[SIG_0:%.*]] = phi ptr [ [[KERNEL]], [[IF_THEN8]] ], [ [[SIGNAL]], [[IF_END6]] ]
; CHECK-NEXT:    [[CMP10120:%.*]] = icmp sgt i32 [[LKERN_0]], 0
; CHECK-NEXT:    br i1 [[CMP10120]], label [[FOR_BODY:%.*]], label [[FOR_COND21_PREHEADER:%.*]]
; CHECK:       for.cond21.preheader:
; CHECK-NEXT:    [[CMP22125:%.*]] = icmp slt i32 [[LKERN_0]], [[LSIG_0]]
; CHECK-NEXT:    br i1 [[CMP22125]], label [[FOR_BODY24:%.*]], label [[FOR_COND42_PREHEADER:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i32 [ [[INDVARS_IV_NEXT:%.*]], [[FOR_END:%.*]] ], [ 1, [[IF_END9]] ]
; CHECK-NEXT:    [[N_0121:%.*]] = phi i32 [ [[INC18:%.*]], [[FOR_END]] ], [ 0, [[IF_END9]] ]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[CONVOUT]], i32 [[N_0121]]
; CHECK-NEXT:    store float 0.000000e+00, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    br label [[FOR_BODY13:%.*]]
; CHECK:       for.body13:
; CHECK-NEXT:    [[K_0119:%.*]] = phi i32 [ 0, [[FOR_BODY]] ], [ [[INC:%.*]], [[FOR_BODY13]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = phi float [ 0.000000e+00, [[FOR_BODY]] ], [ [[TMP3:%.*]], [[FOR_BODY13]] ]
; CHECK-NEXT:    [[ARRAYIDX14:%.*]] = getelementptr inbounds float, ptr [[SIG_0]], i32 [[K_0119]]
; CHECK-NEXT:    [[TMP1:%.*]] = load float, ptr [[ARRAYIDX14]], align 4
; CHECK-NEXT:    [[SUB:%.*]] = sub nsw i32 [[N_0121]], [[K_0119]]
; CHECK-NEXT:    [[ARRAYIDX15:%.*]] = getelementptr inbounds float, ptr [[KERN_0]], i32 [[SUB]]
; CHECK-NEXT:    [[TMP2:%.*]] = load float, ptr [[ARRAYIDX15]], align 4
; CHECK-NEXT:    [[TMP3]] = tail call float @llvm.fmuladd.f32(float [[TMP1]], float [[TMP2]], float [[TMP0]])
; CHECK-NEXT:    store float [[TMP3]], ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[K_0119]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[INC]], [[INDVARS_IV]]
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_END]], label [[FOR_BODY13]]
; CHECK:       for.end:
; CHECK-NEXT:    [[INC18]] = add nuw nsw i32 [[N_0121]], 1
; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw i32 [[INDVARS_IV]], 1
; CHECK-NEXT:    [[EXITCOND132_NOT:%.*]] = icmp eq i32 [[INC18]], [[LKERN_0]]
; CHECK-NEXT:    br i1 [[EXITCOND132_NOT]], label [[FOR_COND21_PREHEADER]], label [[FOR_BODY]]
; CHECK:       for.cond42.preheader:
; CHECK-NEXT:    [[ADD43:%.*]] = add i32 [[SIGLEN]], -1
; CHECK-NEXT:    [[SUB44:%.*]] = add i32 [[ADD43]], [[KERNLEN]]
; CHECK-NEXT:    [[CMP45130:%.*]] = icmp slt i32 [[LSIG_0]], [[SUB44]]
; CHECK-NEXT:    br i1 [[CMP45130]], label [[FOR_BODY47_LR_PH:%.*]], label [[RETURN]]
; CHECK:       for.body47.lr.ph:
; CHECK-NEXT:    [[SUB54:%.*]] = add nsw i32 [[LSIG_0]], -1
; CHECK-NEXT:    br label [[FOR_BODY47:%.*]]
; CHECK:       for.body24:
; CHECK-NEXT:    [[N20_0126:%.*]] = phi i32 [ [[INC39:%.*]], [[FOR_END37:%.*]] ], [ [[LKERN_0]], [[FOR_COND21_PREHEADER]] ]
; CHECK-NEXT:    [[ARRAYIDX26:%.*]] = getelementptr inbounds float, ptr [[CONVOUT]], i32 [[N20_0126]]
; CHECK-NEXT:    store float 0.000000e+00, ptr [[ARRAYIDX26]], align 4
; CHECK-NEXT:    [[SUB27:%.*]] = sub nuw nsw i32 [[N20_0126]], [[LKERN_0]]
; CHECK-NEXT:    [[K25_0122:%.*]] = add i32 [[SUB27]], 1
; CHECK-NEXT:    [[CMP29_NOT123:%.*]] = icmp ugt i32 [[K25_0122]], [[N20_0126]]
; CHECK-NEXT:    br i1 [[CMP29_NOT123]], label [[FOR_END37]], label [[FOR_BODY30:%.*]]
; CHECK:       for.body30:
; CHECK-NEXT:    [[TMP4:%.*]] = phi float [ [[TMP7:%.*]], [[FOR_BODY30]] ], [ 0.000000e+00, [[FOR_BODY24]] ]
; CHECK-NEXT:    [[K25_0124:%.*]] = phi i32 [ [[K25_0:%.*]], [[FOR_BODY30]] ], [ [[K25_0122]], [[FOR_BODY24]] ]
; CHECK-NEXT:    [[ARRAYIDX31:%.*]] = getelementptr inbounds float, ptr [[SIG_0]], i32 [[K25_0124]]
; CHECK-NEXT:    [[TMP5:%.*]] = load float, ptr [[ARRAYIDX31]], align 4
; CHECK-NEXT:    [[SUB32:%.*]] = sub i32 [[N20_0126]], [[K25_0124]]
; CHECK-NEXT:    [[ARRAYIDX33:%.*]] = getelementptr inbounds float, ptr [[KERN_0]], i32 [[SUB32]]
; CHECK-NEXT:    [[TMP6:%.*]] = load float, ptr [[ARRAYIDX33]], align 4
; CHECK-NEXT:    [[TMP7]] = tail call float @llvm.fmuladd.f32(float [[TMP5]], float [[TMP6]], float [[TMP4]])
; CHECK-NEXT:    store float [[TMP7]], ptr [[ARRAYIDX26]], align 4
; CHECK-NEXT:    [[K25_0]] = add i32 [[K25_0124]], 1
; CHECK-NEXT:    [[CMP29_NOT:%.*]] = icmp ugt i32 [[K25_0]], [[N20_0126]]
; CHECK-NEXT:    br i1 [[CMP29_NOT]], label [[FOR_END37]], label [[FOR_BODY30]]
; CHECK:       for.end37:
; CHECK-NEXT:    [[INC39]] = add nuw nsw i32 [[N20_0126]], 1
; CHECK-NEXT:    [[EXITCOND133_NOT:%.*]] = icmp eq i32 [[INC39]], [[LSIG_0]]
; CHECK-NEXT:    br i1 [[EXITCOND133_NOT]], label [[FOR_COND42_PREHEADER]], label [[FOR_BODY24]]
; CHECK:       for.body47:
; CHECK-NEXT:    [[N41_0131:%.*]] = phi i32 [ [[LSIG_0]], [[FOR_BODY47_LR_PH]] ], [ [[INC66:%.*]], [[FOR_END64:%.*]] ]
; CHECK-NEXT:    [[ARRAYIDX51:%.*]] = getelementptr inbounds float, ptr [[CONVOUT]], i32 [[N41_0131]]
; CHECK-NEXT:    store float 0.000000e+00, ptr [[ARRAYIDX51]], align 4
; CHECK-NEXT:    [[SUB52:%.*]] = sub nsw i32 [[N41_0131]], [[LKERN_0]]
; CHECK-NEXT:    [[K50_0127:%.*]] = add i32 [[SUB52]], 1
; CHECK-NEXT:    [[CMP56_NOT128:%.*]] = icmp ugt i32 [[K50_0127]], [[SUB54]]
; CHECK-NEXT:    br i1 [[CMP56_NOT128]], label [[FOR_END64]], label [[FOR_BODY57:%.*]]
; CHECK:       for.body57:
; CHECK-NEXT:    [[TMP8:%.*]] = phi float [ [[TMP11:%.*]], [[FOR_BODY57]] ], [ 0.000000e+00, [[FOR_BODY47]] ]
; CHECK-NEXT:    [[K50_0129:%.*]] = phi i32 [ [[K50_0:%.*]], [[FOR_BODY57]] ], [ [[K50_0127]], [[FOR_BODY47]] ]
; CHECK-NEXT:    [[ARRAYIDX58:%.*]] = getelementptr inbounds float, ptr [[SIG_0]], i32 [[K50_0129]]
; CHECK-NEXT:    [[TMP9:%.*]] = load float, ptr [[ARRAYIDX58]], align 4
; CHECK-NEXT:    [[SUB59:%.*]] = sub i32 [[N41_0131]], [[K50_0129]]
; CHECK-NEXT:    [[ARRAYIDX60:%.*]] = getelementptr inbounds float, ptr [[KERN_0]], i32 [[SUB59]]
; CHECK-NEXT:    [[TMP10:%.*]] = load float, ptr [[ARRAYIDX60]], align 4
; CHECK-NEXT:    [[TMP11]] = tail call float @llvm.fmuladd.f32(float [[TMP9]], float [[TMP10]], float [[TMP8]])
; CHECK-NEXT:    store float [[TMP11]], ptr [[ARRAYIDX51]], align 4
; CHECK-NEXT:    [[K50_0]] = add i32 [[K50_0129]], 1
; CHECK-NEXT:    [[CMP56_NOT:%.*]] = icmp ugt i32 [[K50_0]], [[SUB54]]
; CHECK-NEXT:    br i1 [[CMP56_NOT]], label [[FOR_END64]], label [[FOR_BODY57]]
; CHECK:       for.end64:
; CHECK-NEXT:    [[INC66]] = add nsw i32 [[N41_0131]], 1
; CHECK-NEXT:    [[EXITCOND134_NOT:%.*]] = icmp eq i32 [[INC66]], [[SUB44]]
; CHECK-NEXT:    br i1 [[EXITCOND134_NOT]], label [[RETURN]], label [[FOR_BODY47]]
; CHECK:       return:
; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ 458755, [[ENTRY:%.*]] ], [ 0, [[FOR_COND42_PREHEADER]] ], [ 0, [[FOR_END64]] ]
; CHECK-NEXT:    ret i32 [[RETVAL_0]]
;
entry:
  %cmp = icmp eq ptr %Signal, null
  %cmp1 = icmp eq ptr %Kernel, null
  %or.cond = or i1 %cmp, %cmp1
  %cmp4 = icmp eq ptr %convout, null
  %or.cond118 = or i1 %or.cond, %cmp4
  br i1 %or.cond118, label %return, label %if.end6

if.end6:                                          ; preds = %entry
  %cmp7 = icmp slt i32 %siglen, %kernlen
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end6
  %lkern.0 = phi i32 [ %siglen, %if.then8 ], [ %kernlen, %if.end6 ]
  %lsig.0 = phi i32 [ %kernlen, %if.then8 ], [ %siglen, %if.end6 ]
  %kern.0 = phi ptr [ %Signal, %if.then8 ], [ %Kernel, %if.end6 ]
  %sig.0 = phi ptr [ %Kernel, %if.then8 ], [ %Signal, %if.end6 ]
  %cmp10120 = icmp sgt i32 %lkern.0, 0
  br i1 %cmp10120, label %for.body, label %for.cond21.preheader

for.cond21.preheader:                             ; preds = %for.end, %if.end9
  %cmp22125 = icmp slt i32 %lkern.0, %lsig.0
  br i1 %cmp22125, label %for.body24, label %for.cond42.preheader

for.body:                                         ; preds = %for.end, %if.end9
  %indvars.iv = phi i32 [ %indvars.iv.next, %for.end ], [ 1, %if.end9 ]
  %n.0121 = phi i32 [ %inc18, %for.end ], [ 0, %if.end9 ]
  %arrayidx = getelementptr inbounds float, ptr %convout, i32 %n.0121
  store float 0.000000e+00, ptr %arrayidx, align 4
  br label %for.body13

for.body13:                                       ; preds = %for.body13, %for.body
  %k.0119 = phi i32 [ 0, %for.body ], [ %inc, %for.body13 ]
  %0 = phi float [ 0.000000e+00, %for.body ], [ %3, %for.body13 ]
  %arrayidx14 = getelementptr inbounds float, ptr %sig.0, i32 %k.0119
  %1 = load float, ptr %arrayidx14, align 4
  %sub = sub nsw i32 %n.0121, %k.0119
  %arrayidx15 = getelementptr inbounds float, ptr %kern.0, i32 %sub
  %2 = load float, ptr %arrayidx15, align 4
  %3 = tail call float @llvm.fmuladd.f32(float %1, float %2, float %0)
  store float %3, ptr %arrayidx, align 4
  %inc = add nuw nsw i32 %k.0119, 1
  %exitcond = icmp eq i32 %inc, %indvars.iv
  br i1 %exitcond, label %for.end, label %for.body13

for.end:                                          ; preds = %for.body13
  %inc18 = add nuw nsw i32 %n.0121, 1
  %indvars.iv.next = add nuw i32 %indvars.iv, 1
  %exitcond132.not = icmp eq i32 %inc18, %lkern.0
  br i1 %exitcond132.not, label %for.cond21.preheader, label %for.body

for.cond42.preheader:                             ; preds = %for.end37, %for.cond21.preheader
  %add43 = add i32 %siglen, -1
  %sub44 = add i32 %add43, %kernlen
  %cmp45130 = icmp slt i32 %lsig.0, %sub44
  br i1 %cmp45130, label %for.body47.lr.ph, label %return

for.body47.lr.ph:                                 ; preds = %for.cond42.preheader
  %sub54 = add nsw i32 %lsig.0, -1
  br label %for.body47

for.body24:                                       ; preds = %for.end37, %for.cond21.preheader
  %n20.0126 = phi i32 [ %inc39, %for.end37 ], [ %lkern.0, %for.cond21.preheader ]
  %arrayidx26 = getelementptr inbounds float, ptr %convout, i32 %n20.0126
  store float 0.000000e+00, ptr %arrayidx26, align 4
  %sub27 = sub nuw nsw i32 %n20.0126, %lkern.0
  %k25.0122 = add i32 %sub27, 1
  %cmp29.not123 = icmp ugt i32 %k25.0122, %n20.0126
  br i1 %cmp29.not123, label %for.end37, label %for.body30

for.body30:                                       ; preds = %for.body30, %for.body24
  %4 = phi float [ %7, %for.body30 ], [ 0.000000e+00, %for.body24 ]
  %k25.0124 = phi i32 [ %k25.0, %for.body30 ], [ %k25.0122, %for.body24 ]
  %arrayidx31 = getelementptr inbounds float, ptr %sig.0, i32 %k25.0124
  %5 = load float, ptr %arrayidx31, align 4
  %sub32 = sub i32 %n20.0126, %k25.0124
  %arrayidx33 = getelementptr inbounds float, ptr %kern.0, i32 %sub32
  %6 = load float, ptr %arrayidx33, align 4
  %7 = tail call float @llvm.fmuladd.f32(float %5, float %6, float %4)
  store float %7, ptr %arrayidx26, align 4
  %k25.0 = add i32 %k25.0124, 1
  %cmp29.not = icmp ugt i32 %k25.0, %n20.0126
  br i1 %cmp29.not, label %for.end37, label %for.body30

for.end37:                                        ; preds = %for.body30, %for.body24
  %inc39 = add nuw nsw i32 %n20.0126, 1
  %exitcond133.not = icmp eq i32 %inc39, %lsig.0
  br i1 %exitcond133.not, label %for.cond42.preheader, label %for.body24

for.body47:                                       ; preds = %for.end64, %for.body47.lr.ph
  %n41.0131 = phi i32 [ %lsig.0, %for.body47.lr.ph ], [ %inc66, %for.end64 ]
  %arrayidx51 = getelementptr inbounds float, ptr %convout, i32 %n41.0131
  store float 0.000000e+00, ptr %arrayidx51, align 4
  %sub52 = sub nsw i32 %n41.0131, %lkern.0
  %k50.0127 = add i32 %sub52, 1
  %cmp56.not128 = icmp ugt i32 %k50.0127, %sub54
  br i1 %cmp56.not128, label %for.end64, label %for.body57

for.body57:                                       ; preds = %for.body57, %for.body47
  %8 = phi float [ %11, %for.body57 ], [ 0.000000e+00, %for.body47 ]
  %k50.0129 = phi i32 [ %k50.0, %for.body57 ], [ %k50.0127, %for.body47 ]
  %arrayidx58 = getelementptr inbounds float, ptr %sig.0, i32 %k50.0129
  %9 = load float, ptr %arrayidx58, align 4
  %sub59 = sub i32 %n41.0131, %k50.0129
  %arrayidx60 = getelementptr inbounds float, ptr %kern.0, i32 %sub59
  %10 = load float, ptr %arrayidx60, align 4
  %11 = tail call float @llvm.fmuladd.f32(float %9, float %10, float %8)
  store float %11, ptr %arrayidx51, align 4
  %k50.0 = add i32 %k50.0129, 1
  %cmp56.not = icmp ugt i32 %k50.0, %sub54
  br i1 %cmp56.not, label %for.end64, label %for.body57

for.end64:                                        ; preds = %for.body57, %for.body47
  %inc66 = add nsw i32 %n41.0131, 1
  %exitcond134.not = icmp eq i32 %inc66, %sub44
  br i1 %exitcond134.not, label %return, label %for.body47

return:                                           ; preds = %for.end64, %for.cond42.preheader, %entry
  %retval.0 = phi i32 [ 458755, %entry ], [ 0, %for.cond42.preheader ], [ 0, %for.end64 ]
  ret i32 %retval.0
}
