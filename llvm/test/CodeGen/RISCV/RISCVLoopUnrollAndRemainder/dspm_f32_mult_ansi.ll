; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt -S -mtriple=riscv32-esp-unknown-elf -passes=riscv-loop-unroll-and-remainder -riscv-loop-unroll-and-remainder=true < %s | FileCheck %s

; Function Attrs: nofree norecurse nosync nounwind memory(argmem: readwrite)
define dso_local noundef i32 @dspm_mult_f32_ansi(ptr nocapture noundef readonly %A, ptr nocapture noundef readonly %B, ptr nocapture noundef writeonly %C, i32 noundef %m, i32 noundef %n, i32 noundef %k) local_unnamed_addr {
; CHECK-LABEL: define dso_local noundef i32 @dspm_mult_f32_ansi(
; CHECK-SAME: ptr noalias noundef readonly captures(none) [[A:%.*]], ptr noalias noundef readonly captures(none) [[B:%.*]], ptr noalias noundef writeonly captures(none) [[C:%.*]], i32 noundef [[M:%.*]], i32 noundef [[N:%.*]], i32 noundef [[K:%.*]]) local_unnamed_addr {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP54:%.*]] = icmp sgt i32 [[M]], 0
; CHECK-NEXT:    br i1 [[CMP54]], label [[FOR_COND1_PREHEADER_LR_PH:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.cond1.preheader.lr.ph:
; CHECK-NEXT:    [[CMP252:%.*]] = icmp sgt i32 [[K]], 0
; CHECK-NEXT:    [[SUB6:%.*]] = add nsw i32 [[N]], -7
; CHECK-NEXT:    [[CMP1050:%.*]] = icmp sgt i32 [[N]], 8
; CHECK-NEXT:    br label [[FOR_COND1_PREHEADER:%.*]]
; CHECK:       for.cond1.preheader:
; CHECK-NEXT:    [[I_055:%.*]] = phi i32 [ 0, [[FOR_COND1_PREHEADER_LR_PH]] ], [ [[INC27:%.*]], [[FOR_COND_CLEANUP3:%.*]] ]
; CHECK-NEXT:    br i1 [[CMP252]], label [[FOR_BODY4_LR_PH:%.*]], label [[FOR_COND_CLEANUP3]]
; CHECK:       for.body4.lr.ph:
; CHECK-NEXT:    [[MUL:%.*]] = mul nsw i32 [[I_055]], [[N]]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[A]], i32 [[MUL]]
; CHECK-NEXT:    [[MUL7:%.*]] = mul nuw nsw i32 [[I_055]], [[K]]
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr float, ptr [[C]], i32 [[MUL7]]
; CHECK-NEXT:    [[DOTPRE:%.*]] = load float, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    br label [[FOR_BODY4:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret i32 0
; CHECK:       for.cond.cleanup3:
; CHECK-NEXT:    [[INC27]] = add nuw nsw i32 [[I_055]], 1
; CHECK-NEXT:    [[EXITCOND57_NOT:%.*]] = icmp eq i32 [[INC27]], [[M]]
; CHECK-NEXT:    br i1 [[EXITCOND57_NOT]], label [[FOR_COND_CLEANUP]], label [[FOR_COND1_PREHEADER]]
; CHECK:       for.body4:
; CHECK-NEXT:    [[J_053:%.*]] = phi i32 [ 0, [[FOR_BODY4_LR_PH]] ], [ [[INC24:%.*]], [[FOR_COND_CLEANUP11:%.*]] ]
; CHECK-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr float, ptr [[B]], i32 [[J_053]]
; CHECK-NEXT:    [[TMP1:%.*]] = load float, ptr [[ARRAYIDX5]], align 4
; CHECK-NEXT:    [[MUL6:%.*]] = fmul float [[DOTPRE]], [[TMP1]]
; CHECK-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr float, ptr [[TMP0]], i32 [[J_053]]
; CHECK-NEXT:    store float [[MUL6]], ptr [[ARRAYIDX8]], align 4
; CHECK-NEXT:    br i1 [[CMP1050]], label [[FOR_BODY12_7:%.*]], label [[FOR_COND110_PREHEADER:%.*]]
; CHECK:       for.cond110.preheader:
; CHECK-NEXT:    [[S_0_LCSSA:%.*]] = phi i32 [ 1, [[FOR_BODY4]] ], [ [[INC_7:%.*]], [[FOR_BODY12_7]] ]
; CHECK-NEXT:    [[ACC_0_LCSSA:%.*]] = phi float [ [[MUL6]], [[FOR_BODY4]] ], [ [[TMP26:%.*]], [[FOR_BODY12_7]] ]
; CHECK-NEXT:    [[CMP111262:%.*]] = icmp slt i32 [[S_0_LCSSA]], [[N]]
; CHECK-NEXT:    br i1 [[CMP111262]], label [[FOR_BODY12_CLONE:%.*]], label [[FOR_COND_CLEANUP11]]
; CHECK:       for.body12.7:
; CHECK-NEXT:    [[TMP2:%.*]] = phi float [ [[TMP26]], [[FOR_BODY12_7]] ], [ [[MUL6]], [[FOR_BODY4]] ]
; CHECK-NEXT:    [[S_051:%.*]] = phi i32 [ [[INC_7]], [[FOR_BODY12_7]] ], [ 1, [[FOR_BODY4]] ]
; CHECK-NEXT:    [[ARRAYIDX15:%.*]] = getelementptr float, ptr [[ARRAYIDX]], i32 [[S_051]]
; CHECK-NEXT:    [[TMP3:%.*]] = load float, ptr [[ARRAYIDX15]], align 4
; CHECK-NEXT:    [[MUL16:%.*]] = mul nuw nsw i32 [[S_051]], [[K]]
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr float, ptr [[ARRAYIDX5]], i32 [[MUL16]]
; CHECK-NEXT:    [[TMP4:%.*]] = load float, ptr [[GEP]], align 4
; CHECK-NEXT:    [[TMP5:%.*]] = tail call float @llvm.fmuladd.f32(float [[TMP3]], float [[TMP4]], float [[TMP2]])
; CHECK-NEXT:    store float [[TMP5]], ptr [[ARRAYIDX8]], align 4
; CHECK-NEXT:    [[INC:%.*]] = add nuw nsw i32 [[S_051]], 1
; CHECK-NEXT:    [[ARRAYIDX15_1:%.*]] = getelementptr float, ptr [[ARRAYIDX]], i32 [[INC]]
; CHECK-NEXT:    [[TMP6:%.*]] = load float, ptr [[ARRAYIDX15_1]], align 4
; CHECK-NEXT:    [[MUL16_1:%.*]] = mul nuw nsw i32 [[INC]], [[K]]
; CHECK-NEXT:    [[GEP_1:%.*]] = getelementptr float, ptr [[ARRAYIDX5]], i32 [[MUL16_1]]
; CHECK-NEXT:    [[TMP7:%.*]] = load float, ptr [[GEP_1]], align 4
; CHECK-NEXT:    [[TMP8:%.*]] = tail call float @llvm.fmuladd.f32(float [[TMP6]], float [[TMP7]], float [[TMP5]])
; CHECK-NEXT:    store float [[TMP8]], ptr [[ARRAYIDX8]], align 4
; CHECK-NEXT:    [[INC_1:%.*]] = add nuw nsw i32 [[S_051]], 2
; CHECK-NEXT:    [[ARRAYIDX15_2:%.*]] = getelementptr float, ptr [[ARRAYIDX]], i32 [[INC_1]]
; CHECK-NEXT:    [[TMP9:%.*]] = load float, ptr [[ARRAYIDX15_2]], align 4
; CHECK-NEXT:    [[MUL16_2:%.*]] = mul nuw nsw i32 [[INC_1]], [[K]]
; CHECK-NEXT:    [[GEP_2:%.*]] = getelementptr float, ptr [[ARRAYIDX5]], i32 [[MUL16_2]]
; CHECK-NEXT:    [[TMP10:%.*]] = load float, ptr [[GEP_2]], align 4
; CHECK-NEXT:    [[TMP11:%.*]] = tail call float @llvm.fmuladd.f32(float [[TMP9]], float [[TMP10]], float [[TMP8]])
; CHECK-NEXT:    store float [[TMP11]], ptr [[ARRAYIDX8]], align 4
; CHECK-NEXT:    [[INC_2:%.*]] = add nuw nsw i32 [[S_051]], 3
; CHECK-NEXT:    [[ARRAYIDX15_3:%.*]] = getelementptr float, ptr [[ARRAYIDX]], i32 [[INC_2]]
; CHECK-NEXT:    [[TMP12:%.*]] = load float, ptr [[ARRAYIDX15_3]], align 4
; CHECK-NEXT:    [[MUL16_3:%.*]] = mul nuw nsw i32 [[INC_2]], [[K]]
; CHECK-NEXT:    [[GEP_3:%.*]] = getelementptr float, ptr [[ARRAYIDX5]], i32 [[MUL16_3]]
; CHECK-NEXT:    [[TMP13:%.*]] = load float, ptr [[GEP_3]], align 4
; CHECK-NEXT:    [[TMP14:%.*]] = tail call float @llvm.fmuladd.f32(float [[TMP12]], float [[TMP13]], float [[TMP11]])
; CHECK-NEXT:    store float [[TMP14]], ptr [[ARRAYIDX8]], align 4
; CHECK-NEXT:    [[INC_3:%.*]] = add nuw nsw i32 [[S_051]], 4
; CHECK-NEXT:    [[ARRAYIDX15_4:%.*]] = getelementptr float, ptr [[ARRAYIDX]], i32 [[INC_3]]
; CHECK-NEXT:    [[TMP15:%.*]] = load float, ptr [[ARRAYIDX15_4]], align 4
; CHECK-NEXT:    [[MUL16_4:%.*]] = mul nuw nsw i32 [[INC_3]], [[K]]
; CHECK-NEXT:    [[GEP_4:%.*]] = getelementptr float, ptr [[ARRAYIDX5]], i32 [[MUL16_4]]
; CHECK-NEXT:    [[TMP16:%.*]] = load float, ptr [[GEP_4]], align 4
; CHECK-NEXT:    [[TMP17:%.*]] = tail call float @llvm.fmuladd.f32(float [[TMP15]], float [[TMP16]], float [[TMP14]])
; CHECK-NEXT:    store float [[TMP17]], ptr [[ARRAYIDX8]], align 4
; CHECK-NEXT:    [[INC_4:%.*]] = add nuw nsw i32 [[S_051]], 5
; CHECK-NEXT:    [[ARRAYIDX15_5:%.*]] = getelementptr float, ptr [[ARRAYIDX]], i32 [[INC_4]]
; CHECK-NEXT:    [[TMP18:%.*]] = load float, ptr [[ARRAYIDX15_5]], align 4
; CHECK-NEXT:    [[MUL16_5:%.*]] = mul nuw nsw i32 [[INC_4]], [[K]]
; CHECK-NEXT:    [[GEP_5:%.*]] = getelementptr float, ptr [[ARRAYIDX5]], i32 [[MUL16_5]]
; CHECK-NEXT:    [[TMP19:%.*]] = load float, ptr [[GEP_5]], align 4
; CHECK-NEXT:    [[TMP20:%.*]] = tail call float @llvm.fmuladd.f32(float [[TMP18]], float [[TMP19]], float [[TMP17]])
; CHECK-NEXT:    store float [[TMP20]], ptr [[ARRAYIDX8]], align 4
; CHECK-NEXT:    [[INC_5:%.*]] = add nuw nsw i32 [[S_051]], 6
; CHECK-NEXT:    [[ARRAYIDX15_6:%.*]] = getelementptr float, ptr [[ARRAYIDX]], i32 [[INC_5]]
; CHECK-NEXT:    [[TMP21:%.*]] = load float, ptr [[ARRAYIDX15_6]], align 4
; CHECK-NEXT:    [[MUL16_6:%.*]] = mul nuw nsw i32 [[INC_5]], [[K]]
; CHECK-NEXT:    [[GEP_6:%.*]] = getelementptr float, ptr [[ARRAYIDX5]], i32 [[MUL16_6]]
; CHECK-NEXT:    [[TMP22:%.*]] = load float, ptr [[GEP_6]], align 4
; CHECK-NEXT:    [[TMP23:%.*]] = tail call float @llvm.fmuladd.f32(float [[TMP21]], float [[TMP22]], float [[TMP20]])
; CHECK-NEXT:    store float [[TMP23]], ptr [[ARRAYIDX8]], align 4
; CHECK-NEXT:    [[INC_6:%.*]] = add nuw nsw i32 [[S_051]], 7
; CHECK-NEXT:    [[ARRAYIDX15_7:%.*]] = getelementptr float, ptr [[ARRAYIDX]], i32 [[INC_6]]
; CHECK-NEXT:    [[TMP24:%.*]] = load float, ptr [[ARRAYIDX15_7]], align 4
; CHECK-NEXT:    [[MUL16_7:%.*]] = mul nuw nsw i32 [[INC_6]], [[K]]
; CHECK-NEXT:    [[GEP_7:%.*]] = getelementptr float, ptr [[ARRAYIDX5]], i32 [[MUL16_7]]
; CHECK-NEXT:    [[TMP25:%.*]] = load float, ptr [[GEP_7]], align 4
; CHECK-NEXT:    [[TMP26]] = tail call float @llvm.fmuladd.f32(float [[TMP24]], float [[TMP25]], float [[TMP23]])
; CHECK-NEXT:    store float [[TMP26]], ptr [[ARRAYIDX8]], align 4
; CHECK-NEXT:    [[INC_7]] = add nuw nsw i32 [[S_051]], 8
; CHECK-NEXT:    [[EXITCOND_NOT_7:%.*]] = icmp slt i32 [[INC_7]], [[SUB6]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT_7]], label [[FOR_BODY12_7]], label [[FOR_COND110_PREHEADER]]
; CHECK:       for.body12.clone:
; CHECK-NEXT:    [[TMP27:%.*]] = phi float [ [[TMP30:%.*]], [[FOR_BODY12_CLONE]] ], [ [[ACC_0_LCSSA]], [[FOR_COND110_PREHEADER]] ]
; CHECK-NEXT:    [[S_051_CLONE:%.*]] = phi i32 [ [[INC_CLONE:%.*]], [[FOR_BODY12_CLONE]] ], [ [[S_0_LCSSA]], [[FOR_COND110_PREHEADER]] ]
; CHECK-NEXT:    [[ARRAYIDX15_CLONE:%.*]] = getelementptr float, ptr [[ARRAYIDX]], i32 [[S_051_CLONE]]
; CHECK-NEXT:    [[TMP28:%.*]] = load float, ptr [[ARRAYIDX15_CLONE]], align 4
; CHECK-NEXT:    [[MUL16_CLONE:%.*]] = mul nsw i32 [[S_051_CLONE]], [[K]]
; CHECK-NEXT:    [[GEP_CLONE:%.*]] = getelementptr float, ptr [[ARRAYIDX5]], i32 [[MUL16_CLONE]]
; CHECK-NEXT:    [[TMP29:%.*]] = load float, ptr [[GEP_CLONE]], align 4
; CHECK-NEXT:    [[TMP30]] = tail call float @llvm.fmuladd.f32(float [[TMP28]], float [[TMP29]], float [[TMP27]])
; CHECK-NEXT:    store float [[TMP30]], ptr [[ARRAYIDX8]], align 4
; CHECK-NEXT:    [[INC_CLONE]] = add nuw nsw i32 [[S_051_CLONE]], 1
; CHECK-NEXT:    [[EXITCOND_NOT_CLONE:%.*]] = icmp eq i32 [[INC_CLONE]], [[N]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT_CLONE]], label [[FOR_COND_CLEANUP11]], label [[FOR_BODY12_CLONE]]
; CHECK:       for.cond.cleanup11:
; CHECK-NEXT:    [[INC24]] = add nuw nsw i32 [[J_053]], 1
; CHECK-NEXT:    [[EXITCOND56_NOT:%.*]] = icmp eq i32 [[INC24]], [[K]]
; CHECK-NEXT:    br i1 [[EXITCOND56_NOT]], label [[FOR_COND_CLEANUP3]], label [[FOR_BODY4]]
;
entry:
  %cmp54 = icmp sgt i32 %m, 0
  br i1 %cmp54, label %for.cond1.preheader.lr.ph, label %for.cond.cleanup

for.cond1.preheader.lr.ph:                        ; preds = %entry
  %cmp252 = icmp sgt i32 %k, 0
  %cmp1050 = icmp sgt i32 %n, 1
  br label %for.cond1.preheader

for.cond1.preheader:                              ; preds = %for.cond.cleanup3, %for.cond1.preheader.lr.ph
  %i.055 = phi i32 [ 0, %for.cond1.preheader.lr.ph ], [ %inc27, %for.cond.cleanup3 ]
  br i1 %cmp252, label %for.body4.lr.ph, label %for.cond.cleanup3

for.body4.lr.ph:                                  ; preds = %for.cond1.preheader
  %mul = mul nsw i32 %i.055, %n
  %arrayidx = getelementptr inbounds float, ptr %A, i32 %mul
  %mul7 = mul nsw i32 %i.055, %k
  %0 = getelementptr float, ptr %C, i32 %mul7
  br label %for.body4

for.cond.cleanup:                                 ; preds = %for.cond.cleanup3, %entry
  ret i32 0

for.cond.cleanup3:                                ; preds = %for.cond.cleanup11, %for.cond1.preheader
  %inc27 = add nuw nsw i32 %i.055, 1
  %exitcond57.not = icmp eq i32 %inc27, %m
  br i1 %exitcond57.not, label %for.cond.cleanup, label %for.cond1.preheader

for.body4:                                        ; preds = %for.cond.cleanup11, %for.body4.lr.ph
  %j.053 = phi i32 [ 0, %for.body4.lr.ph ], [ %inc24, %for.cond.cleanup11 ]
  %1 = load float, ptr %arrayidx, align 4
  %arrayidx5 = getelementptr float, ptr %B, i32 %j.053
  %2 = load float, ptr %arrayidx5, align 4
  %mul6 = fmul float %1, %2
  %arrayidx8 = getelementptr float, ptr %0, i32 %j.053
  store float %mul6, ptr %arrayidx8, align 4
  br i1 %cmp1050, label %for.body12, label %for.cond.cleanup11

for.cond.cleanup11:                               ; preds = %for.body12, %for.body4
  %inc24 = add nuw nsw i32 %j.053, 1
  %exitcond56.not = icmp eq i32 %inc24, %k
  br i1 %exitcond56.not, label %for.cond.cleanup3, label %for.body4

for.body12:                                       ; preds = %for.body12, %for.body4
  %3 = phi float [ %6, %for.body12 ], [ %mul6, %for.body4 ]
  %s.051 = phi i32 [ %inc, %for.body12 ], [ 1, %for.body4 ]
  %arrayidx15 = getelementptr float, ptr %arrayidx, i32 %s.051
  %4 = load float, ptr %arrayidx15, align 4
  %mul16 = mul nsw i32 %s.051, %k
  %gep = getelementptr float, ptr %arrayidx5, i32 %mul16
  %5 = load float, ptr %gep, align 4
  %6 = tail call float @llvm.fmuladd.f32(float %4, float %5, float %3)
  store float %6, ptr %arrayidx8, align 4
  %inc = add nuw nsw i32 %s.051, 1
  %exitcond.not = icmp eq i32 %inc, %n
  br i1 %exitcond.not, label %for.cond.cleanup11, label %for.body12
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.fmuladd.f32(float, float, float)


