; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt -S -mtriple=riscv32-esp-unknown-elf -passes=riscv-loop-unroll-and-remainder -riscv-loop-unroll-and-remainder=true < %s | FileCheck %s

; Function Attrs: nofree norecurse nosync nounwind memory(argmem: readwrite)
define dso_local noundef i32 @dspm_mult_ex_f32_ansi(ptr noundef readonly %A, ptr noundef readonly %B, ptr noundef writeonly %C, i32 noundef %A_rows, i32 noundef %A_cols, i32 noundef %B_cols, i32 noundef %A_padding, i32 noundef %B_padding, i32 noundef %C_padding) local_unnamed_addr {
; CHECK-LABEL: define dso_local noundef i32 @dspm_mult_ex_f32_ansi(
; CHECK-SAME: ptr noalias noundef readonly [[A:%.*]], ptr noalias noundef readonly [[B:%.*]], ptr noalias noundef writeonly [[C:%.*]], i32 noundef [[A_ROWS:%.*]], i32 noundef [[A_COLS:%.*]], i32 noundef [[B_COLS:%.*]], i32 noundef [[A_PADDING:%.*]], i32 noundef [[B_PADDING:%.*]], i32 noundef [[C_PADDING:%.*]]) local_unnamed_addr {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq ptr [[A]], null
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq ptr [[B]], null
; CHECK-NEXT:    [[OR_COND:%.*]] = or i1 [[CMP]], [[CMP1]]
; CHECK-NEXT:    [[CMP4:%.*]] = icmp eq ptr [[C]], null
; CHECK-NEXT:    [[OR_COND87:%.*]] = or i1 [[OR_COND]], [[CMP4]]
; CHECK-NEXT:    [[CMP7:%.*]] = icmp slt i32 [[A_ROWS]], 1
; CHECK-NEXT:    [[OR_COND88:%.*]] = or i1 [[OR_COND87]], [[CMP7]]
; CHECK-NEXT:    [[CMP10:%.*]] = icmp slt i32 [[A_COLS]], 1
; CHECK-NEXT:    [[OR_COND89:%.*]] = or i1 [[OR_COND88]], [[CMP10]]
; CHECK-NEXT:    [[CMP13:%.*]] = icmp slt i32 [[B_COLS]], 1
; CHECK-NEXT:    [[OR_COND90:%.*]] = or i1 [[OR_COND89]], [[CMP13]]
; CHECK-NEXT:    [[TMP0:%.*]] = or i32 [[B_PADDING]], [[A_PADDING]]
; CHECK-NEXT:    [[TMP1:%.*]] = or i32 [[TMP0]], [[C_PADDING]]
; CHECK-NEXT:    [[TMP2:%.*]] = icmp slt i32 [[TMP1]], 0
; CHECK-NEXT:    [[OR_COND93:%.*]] = or i1 [[OR_COND90]], [[TMP2]]
; CHECK-NEXT:    br i1 [[OR_COND93]], label [[RETURN:%.*]], label [[IF_END24:%.*]]
; CHECK:       if.end24:
; CHECK-NEXT:    [[ADD:%.*]] = add nuw nsw i32 [[A_PADDING]], [[A_COLS]]
; CHECK-NEXT:    [[ADD25:%.*]] = add nuw nsw i32 [[B_PADDING]], [[B_COLS]]
; CHECK-NEXT:    [[ADD26:%.*]] = add nuw nsw i32 [[C_PADDING]], [[B_COLS]]
; CHECK-NEXT:    [[SUB6:%.*]] = add nsw i32 [[A_COLS]], -7
; CHECK-NEXT:    [[CMP3894:%.*]] = icmp ugt i32 [[A_COLS]], 8
; CHECK-NEXT:    br label [[FOR_BODY31_LR_PH:%.*]]
; CHECK:       for.body31.lr.ph:
; CHECK-NEXT:    [[I_098:%.*]] = phi i32 [ 0, [[IF_END24]] ], [ [[INC55:%.*]], [[FOR_COND_CLEANUP30:%.*]] ]
; CHECK-NEXT:    [[MUL:%.*]] = mul nsw i32 [[I_098]], [[ADD]]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[A]], i32 [[MUL]]
; CHECK-NEXT:    [[MUL34:%.*]] = mul nsw i32 [[I_098]], [[ADD26]]
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr float, ptr [[C]], i32 [[MUL34]]
; CHECK-NEXT:    [[DOTPRE:%.*]] = load float, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    br label [[FOR_BODY31:%.*]]
; CHECK:       for.cond.cleanup30:
; CHECK-NEXT:    [[INC55]] = add nuw nsw i32 [[I_098]], 1
; CHECK-NEXT:    [[EXITCOND100_NOT:%.*]] = icmp eq i32 [[INC55]], [[A_ROWS]]
; CHECK-NEXT:    br i1 [[EXITCOND100_NOT]], label [[RETURN]], label [[FOR_BODY31_LR_PH]]
; CHECK:       for.body31:
; CHECK-NEXT:    [[J_097:%.*]] = phi i32 [ 0, [[FOR_BODY31_LR_PH]] ], [ [[INC52:%.*]], [[FOR_COND_CLEANUP39:%.*]] ]
; CHECK-NEXT:    [[ARRAYIDX32:%.*]] = getelementptr float, ptr [[B]], i32 [[J_097]]
; CHECK-NEXT:    [[TMP4:%.*]] = load float, ptr [[ARRAYIDX32]], align 4
; CHECK-NEXT:    [[MUL33:%.*]] = fmul float [[DOTPRE]], [[TMP4]]
; CHECK-NEXT:    [[ARRAYIDX36:%.*]] = getelementptr float, ptr [[TMP3]], i32 [[J_097]]
; CHECK-NEXT:    store float [[MUL33]], ptr [[ARRAYIDX36]], align 4
; CHECK-NEXT:    br i1 [[CMP3894]], label [[FOR_BODY40_7:%.*]], label [[FOR_COND110_PREHEADER:%.*]]
; CHECK:       for.cond110.preheader:
; CHECK-NEXT:    [[S_0_LCSSA:%.*]] = phi i32 [ 1, [[FOR_BODY31]] ], [ [[INC_7:%.*]], [[FOR_BODY40_7]] ]
; CHECK-NEXT:    [[ACC_0_LCSSA:%.*]] = phi float [ [[MUL33]], [[FOR_BODY31]] ], [ [[TMP29:%.*]], [[FOR_BODY40_7]] ]
; CHECK-NEXT:    [[CMP111262:%.*]] = icmp slt i32 [[S_0_LCSSA]], [[A_COLS]]
; CHECK-NEXT:    br i1 [[CMP111262]], label [[FOR_BODY40_CLONE:%.*]], label [[FOR_COND_CLEANUP39]]
; CHECK:       for.body40.7:
; CHECK-NEXT:    [[TMP5:%.*]] = phi float [ [[TMP29]], [[FOR_BODY40_7]] ], [ [[MUL33]], [[FOR_BODY31]] ]
; CHECK-NEXT:    [[S_095:%.*]] = phi i32 [ [[INC_7]], [[FOR_BODY40_7]] ], [ 1, [[FOR_BODY31]] ]
; CHECK-NEXT:    [[ARRAYIDX43:%.*]] = getelementptr float, ptr [[ARRAYIDX]], i32 [[S_095]]
; CHECK-NEXT:    [[TMP6:%.*]] = load float, ptr [[ARRAYIDX43]], align 4
; CHECK-NEXT:    [[MUL44:%.*]] = mul nsw i32 [[S_095]], [[ADD25]]
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr float, ptr [[ARRAYIDX32]], i32 [[MUL44]]
; CHECK-NEXT:    [[TMP7:%.*]] = load float, ptr [[GEP]], align 4
; CHECK-NEXT:    [[TMP8:%.*]] = tail call float @llvm.fmuladd.f32(float [[TMP6]], float [[TMP7]], float [[TMP5]])
; CHECK-NEXT:    store float [[TMP8]], ptr [[ARRAYIDX36]], align 4
; CHECK-NEXT:    [[INC:%.*]] = add nuw nsw i32 [[S_095]], 1
; CHECK-NEXT:    [[ARRAYIDX43_1:%.*]] = getelementptr float, ptr [[ARRAYIDX]], i32 [[INC]]
; CHECK-NEXT:    [[TMP9:%.*]] = load float, ptr [[ARRAYIDX43_1]], align 4
; CHECK-NEXT:    [[MUL44_1:%.*]] = mul nsw i32 [[INC]], [[ADD25]]
; CHECK-NEXT:    [[GEP_1:%.*]] = getelementptr float, ptr [[ARRAYIDX32]], i32 [[MUL44_1]]
; CHECK-NEXT:    [[TMP10:%.*]] = load float, ptr [[GEP_1]], align 4
; CHECK-NEXT:    [[TMP11:%.*]] = tail call float @llvm.fmuladd.f32(float [[TMP9]], float [[TMP10]], float [[TMP8]])
; CHECK-NEXT:    store float [[TMP11]], ptr [[ARRAYIDX36]], align 4
; CHECK-NEXT:    [[INC_1:%.*]] = add nuw nsw i32 [[S_095]], 2
; CHECK-NEXT:    [[ARRAYIDX43_2:%.*]] = getelementptr float, ptr [[ARRAYIDX]], i32 [[INC_1]]
; CHECK-NEXT:    [[TMP12:%.*]] = load float, ptr [[ARRAYIDX43_2]], align 4
; CHECK-NEXT:    [[MUL44_2:%.*]] = mul nsw i32 [[INC_1]], [[ADD25]]
; CHECK-NEXT:    [[GEP_2:%.*]] = getelementptr float, ptr [[ARRAYIDX32]], i32 [[MUL44_2]]
; CHECK-NEXT:    [[TMP13:%.*]] = load float, ptr [[GEP_2]], align 4
; CHECK-NEXT:    [[TMP14:%.*]] = tail call float @llvm.fmuladd.f32(float [[TMP12]], float [[TMP13]], float [[TMP11]])
; CHECK-NEXT:    store float [[TMP14]], ptr [[ARRAYIDX36]], align 4
; CHECK-NEXT:    [[INC_2:%.*]] = add nuw nsw i32 [[S_095]], 3
; CHECK-NEXT:    [[ARRAYIDX43_3:%.*]] = getelementptr float, ptr [[ARRAYIDX]], i32 [[INC_2]]
; CHECK-NEXT:    [[TMP15:%.*]] = load float, ptr [[ARRAYIDX43_3]], align 4
; CHECK-NEXT:    [[MUL44_3:%.*]] = mul nsw i32 [[INC_2]], [[ADD25]]
; CHECK-NEXT:    [[GEP_3:%.*]] = getelementptr float, ptr [[ARRAYIDX32]], i32 [[MUL44_3]]
; CHECK-NEXT:    [[TMP16:%.*]] = load float, ptr [[GEP_3]], align 4
; CHECK-NEXT:    [[TMP17:%.*]] = tail call float @llvm.fmuladd.f32(float [[TMP15]], float [[TMP16]], float [[TMP14]])
; CHECK-NEXT:    store float [[TMP17]], ptr [[ARRAYIDX36]], align 4
; CHECK-NEXT:    [[INC_3:%.*]] = add nuw nsw i32 [[S_095]], 4
; CHECK-NEXT:    [[ARRAYIDX43_4:%.*]] = getelementptr float, ptr [[ARRAYIDX]], i32 [[INC_3]]
; CHECK-NEXT:    [[TMP18:%.*]] = load float, ptr [[ARRAYIDX43_4]], align 4
; CHECK-NEXT:    [[MUL44_4:%.*]] = mul nsw i32 [[INC_3]], [[ADD25]]
; CHECK-NEXT:    [[GEP_4:%.*]] = getelementptr float, ptr [[ARRAYIDX32]], i32 [[MUL44_4]]
; CHECK-NEXT:    [[TMP19:%.*]] = load float, ptr [[GEP_4]], align 4
; CHECK-NEXT:    [[TMP20:%.*]] = tail call float @llvm.fmuladd.f32(float [[TMP18]], float [[TMP19]], float [[TMP17]])
; CHECK-NEXT:    store float [[TMP20]], ptr [[ARRAYIDX36]], align 4
; CHECK-NEXT:    [[INC_4:%.*]] = add nuw nsw i32 [[S_095]], 5
; CHECK-NEXT:    [[ARRAYIDX43_5:%.*]] = getelementptr float, ptr [[ARRAYIDX]], i32 [[INC_4]]
; CHECK-NEXT:    [[TMP21:%.*]] = load float, ptr [[ARRAYIDX43_5]], align 4
; CHECK-NEXT:    [[MUL44_5:%.*]] = mul nsw i32 [[INC_4]], [[ADD25]]
; CHECK-NEXT:    [[GEP_5:%.*]] = getelementptr float, ptr [[ARRAYIDX32]], i32 [[MUL44_5]]
; CHECK-NEXT:    [[TMP22:%.*]] = load float, ptr [[GEP_5]], align 4
; CHECK-NEXT:    [[TMP23:%.*]] = tail call float @llvm.fmuladd.f32(float [[TMP21]], float [[TMP22]], float [[TMP20]])
; CHECK-NEXT:    store float [[TMP23]], ptr [[ARRAYIDX36]], align 4
; CHECK-NEXT:    [[INC_5:%.*]] = add nuw nsw i32 [[S_095]], 6
; CHECK-NEXT:    [[ARRAYIDX43_6:%.*]] = getelementptr float, ptr [[ARRAYIDX]], i32 [[INC_5]]
; CHECK-NEXT:    [[TMP24:%.*]] = load float, ptr [[ARRAYIDX43_6]], align 4
; CHECK-NEXT:    [[MUL44_6:%.*]] = mul nsw i32 [[INC_5]], [[ADD25]]
; CHECK-NEXT:    [[GEP_6:%.*]] = getelementptr float, ptr [[ARRAYIDX32]], i32 [[MUL44_6]]
; CHECK-NEXT:    [[TMP25:%.*]] = load float, ptr [[GEP_6]], align 4
; CHECK-NEXT:    [[TMP26:%.*]] = tail call float @llvm.fmuladd.f32(float [[TMP24]], float [[TMP25]], float [[TMP23]])
; CHECK-NEXT:    store float [[TMP26]], ptr [[ARRAYIDX36]], align 4
; CHECK-NEXT:    [[INC_6:%.*]] = add nuw nsw i32 [[S_095]], 7
; CHECK-NEXT:    [[ARRAYIDX43_7:%.*]] = getelementptr float, ptr [[ARRAYIDX]], i32 [[INC_6]]
; CHECK-NEXT:    [[TMP27:%.*]] = load float, ptr [[ARRAYIDX43_7]], align 4
; CHECK-NEXT:    [[MUL44_7:%.*]] = mul nsw i32 [[INC_6]], [[ADD25]]
; CHECK-NEXT:    [[GEP_7:%.*]] = getelementptr float, ptr [[ARRAYIDX32]], i32 [[MUL44_7]]
; CHECK-NEXT:    [[TMP28:%.*]] = load float, ptr [[GEP_7]], align 4
; CHECK-NEXT:    [[TMP29]] = tail call float @llvm.fmuladd.f32(float [[TMP27]], float [[TMP28]], float [[TMP26]])
; CHECK-NEXT:    store float [[TMP29]], ptr [[ARRAYIDX36]], align 4
; CHECK-NEXT:    [[INC_7]] = add nuw nsw i32 [[S_095]], 8
; CHECK-NEXT:    [[EXITCOND_NOT_7:%.*]] = icmp slt i32 [[INC_7]], [[SUB6]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT_7]], label [[FOR_BODY40_7]], label [[FOR_COND110_PREHEADER]]
; CHECK:       for.body40.clone:
; CHECK-NEXT:    [[TMP30:%.*]] = phi float [ [[TMP33:%.*]], [[FOR_BODY40_CLONE]] ], [ [[ACC_0_LCSSA]], [[FOR_COND110_PREHEADER]] ]
; CHECK-NEXT:    [[S_095_CLONE:%.*]] = phi i32 [ [[INC_CLONE:%.*]], [[FOR_BODY40_CLONE]] ], [ [[S_0_LCSSA]], [[FOR_COND110_PREHEADER]] ]
; CHECK-NEXT:    [[ARRAYIDX43_CLONE:%.*]] = getelementptr float, ptr [[ARRAYIDX]], i32 [[S_095_CLONE]]
; CHECK-NEXT:    [[TMP31:%.*]] = load float, ptr [[ARRAYIDX43_CLONE]], align 4
; CHECK-NEXT:    [[MUL44_CLONE:%.*]] = mul nsw i32 [[S_095_CLONE]], [[ADD25]]
; CHECK-NEXT:    [[GEP_CLONE:%.*]] = getelementptr float, ptr [[ARRAYIDX32]], i32 [[MUL44_CLONE]]
; CHECK-NEXT:    [[TMP32:%.*]] = load float, ptr [[GEP_CLONE]], align 4
; CHECK-NEXT:    [[TMP33]] = tail call float @llvm.fmuladd.f32(float [[TMP31]], float [[TMP32]], float [[TMP30]])
; CHECK-NEXT:    store float [[TMP33]], ptr [[ARRAYIDX36]], align 4
; CHECK-NEXT:    [[INC_CLONE]] = add nuw nsw i32 [[S_095_CLONE]], 1
; CHECK-NEXT:    [[EXITCOND_NOT_CLONE:%.*]] = icmp eq i32 [[INC_CLONE]], [[A_COLS]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT_CLONE]], label [[FOR_COND_CLEANUP39]], label [[FOR_BODY40_CLONE]]
; CHECK:       for.cond.cleanup39:
; CHECK-NEXT:    [[INC52]] = add nuw nsw i32 [[J_097]], 1
; CHECK-NEXT:    [[EXITCOND99_NOT:%.*]] = icmp eq i32 [[INC52]], [[B_COLS]]
; CHECK-NEXT:    br i1 [[EXITCOND99_NOT]], label [[FOR_COND_CLEANUP30]], label [[FOR_BODY31]]
; CHECK:       return:
; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ 458755, [[ENTRY:%.*]] ], [ 0, [[FOR_COND_CLEANUP30]] ]
; CHECK-NEXT:    ret i32 [[RETVAL_0]]
;
entry:
  %cmp = icmp eq ptr %A, null
  %cmp1 = icmp eq ptr %B, null
  %or.cond = or i1 %cmp, %cmp1
  %cmp4 = icmp eq ptr %C, null
  %or.cond87 = or i1 %or.cond, %cmp4
  %cmp7 = icmp slt i32 %A_rows, 1
  %or.cond88 = or i1 %or.cond87, %cmp7
  %cmp10 = icmp slt i32 %A_cols, 1
  %or.cond89 = or i1 %or.cond88, %cmp10
  %cmp13 = icmp slt i32 %B_cols, 1
  %or.cond90 = or i1 %or.cond89, %cmp13
  %0 = or i32 %B_padding, %A_padding
  %1 = or i32 %0, %C_padding
  %2 = icmp slt i32 %1, 0
  %or.cond93 = or i1 %or.cond90, %2
  br i1 %or.cond93, label %return, label %if.end24

if.end24:                                         ; preds = %entry
  %add = add nuw nsw i32 %A_padding, %A_cols
  %add25 = add nuw nsw i32 %B_padding, %B_cols
  %add26 = add nuw nsw i32 %C_padding, %B_cols
  %cmp3894 = icmp ugt i32 %A_cols, 1
  br label %for.body31.lr.ph

for.body31.lr.ph:                                 ; preds = %for.cond.cleanup30, %if.end24
  %i.098 = phi i32 [ 0, %if.end24 ], [ %inc55, %for.cond.cleanup30 ]
  %mul = mul nsw i32 %i.098, %add
  %arrayidx = getelementptr inbounds float, ptr %A, i32 %mul
  %mul34 = mul nsw i32 %i.098, %add26
  %3 = getelementptr float, ptr %C, i32 %mul34
  br label %for.body31

for.cond.cleanup30:                               ; preds = %for.cond.cleanup39
  %inc55 = add nuw nsw i32 %i.098, 1
  %exitcond100.not = icmp eq i32 %inc55, %A_rows
  br i1 %exitcond100.not, label %return, label %for.body31.lr.ph

for.body31:                                       ; preds = %for.cond.cleanup39, %for.body31.lr.ph
  %j.097 = phi i32 [ 0, %for.body31.lr.ph ], [ %inc52, %for.cond.cleanup39 ]
  %4 = load float, ptr %arrayidx, align 4
  %arrayidx32 = getelementptr float, ptr %B, i32 %j.097
  %5 = load float, ptr %arrayidx32, align 4
  %mul33 = fmul float %4, %5
  %arrayidx36 = getelementptr float, ptr %3, i32 %j.097
  store float %mul33, ptr %arrayidx36, align 4
  br i1 %cmp3894, label %for.body40, label %for.cond.cleanup39

for.cond.cleanup39:                               ; preds = %for.body40, %for.body31
  %inc52 = add nuw nsw i32 %j.097, 1
  %exitcond99.not = icmp eq i32 %inc52, %B_cols
  br i1 %exitcond99.not, label %for.cond.cleanup30, label %for.body31

for.body40:                                       ; preds = %for.body40, %for.body31
  %6 = phi float [ %9, %for.body40 ], [ %mul33, %for.body31 ]
  %s.095 = phi i32 [ %inc, %for.body40 ], [ 1, %for.body31 ]
  %arrayidx43 = getelementptr float, ptr %arrayidx, i32 %s.095
  %7 = load float, ptr %arrayidx43, align 4
  %mul44 = mul nsw i32 %s.095, %add25
  %gep = getelementptr float, ptr %arrayidx32, i32 %mul44
  %8 = load float, ptr %gep, align 4
  %9 = tail call float @llvm.fmuladd.f32(float %7, float %8, float %6)
  store float %9, ptr %arrayidx36, align 4
  %inc = add nuw nsw i32 %s.095, 1
  %exitcond.not = icmp eq i32 %inc, %A_cols
  br i1 %exitcond.not, label %for.cond.cleanup39, label %for.body40

return:                                           ; preds = %for.cond.cleanup30, %entry
  %retval.0 = phi i32 [ 458755, %entry ], [ 0, %for.cond.cleanup30 ]
  ret i32 %retval.0
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.fmuladd.f32(float, float, float)
