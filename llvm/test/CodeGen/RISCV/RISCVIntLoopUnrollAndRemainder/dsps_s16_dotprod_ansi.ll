; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt -S -mtriple=riscv32-esp-unknown-elf -passes=riscv-int-loop-unroll-and-remainder -riscv-int-loop-unroll-and-remainder=false < %s | FileCheck %s

; Function Attrs: nofree norecurse nosync nounwind memory(argmem: readwrite)
define dso_local noundef i32 @dsps_dotprod_s16_ansi(ptr nocapture noundef readonly %src1, ptr nocapture noundef readonly %src2, ptr nocapture noundef writeonly %dest, i32 noundef %len, i8 noundef signext %shift) local_unnamed_addr {
; CHECK-LABEL: define dso_local noundef i32 @dsps_dotprod_s16_ansi(
; CHECK-SAME: ptr nocapture noundef readonly [[SRC1:%.*]], ptr nocapture noundef readonly [[SRC2:%.*]], ptr nocapture noundef writeonly [[DEST:%.*]], i32 noundef [[LEN:%.*]], i8 noundef signext [[SHIFT:%.*]]) local_unnamed_addr {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CONV:%.*]] = sext i8 [[SHIFT]] to i32
; CHECK-NEXT:    [[SHR:%.*]] = lshr i32 32767, [[CONV]]
; CHECK-NEXT:    [[CONV1:%.*]] = zext nneg i32 [[SHR]] to i64
; CHECK-NEXT:    [[CMP74172:%.*]] = icmp sgt i32 [[LEN]], 0
; CHECK-NEXT:    br i1 [[CMP74172]], label [[FOR_BODY_CLONE:%.*]], label [[FOR_END85:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    [[ACC_0_LCSSA:%.*]] = phi i64 [ [[CONV1]], [[ENTRY:%.*]] ], [ [[ADD_CLONE:%.*]], [[FOR_BODY_CLONE]] ]
; CHECK-NEXT:    [[EXITCOND_NOT_7:%.*]] = icmp sgt i8 [[SHIFT]], 15
; CHECK-NEXT:    br i1 [[EXITCOND_NOT_7]], label [[FOR_BODY_7:%.*]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[TMP19:%.*]] = phi i64 [ [[ADD_CLONE]], [[FOR_BODY_CLONE]] ], [ [[CONV1]], [[ENTRY]] ]
; CHECK-NEXT:    [[I_025_CLONE:%.*]] = phi i32 [ [[INC_CLONE:%.*]], [[FOR_BODY_CLONE]] ], [ 0, [[ENTRY]] ]
; CHECK-NEXT:    [[ARRAYIDX_CLONE:%.*]] = getelementptr inbounds i16, ptr [[SRC1]], i32 [[I_025_CLONE]]
; CHECK-NEXT:    [[TMP20:%.*]] = load i16, ptr [[ARRAYIDX_CLONE]], align 2
; CHECK-NEXT:    [[CONV3_CLONE:%.*]] = sext i16 [[TMP20]] to i32
; CHECK-NEXT:    [[ARRAYIDX4_CLONE:%.*]] = getelementptr inbounds i16, ptr [[SRC2]], i32 [[I_025_CLONE]]
; CHECK-NEXT:    [[TMP21:%.*]] = load i16, ptr [[ARRAYIDX4_CLONE]], align 2
; CHECK-NEXT:    [[CONV5_CLONE:%.*]] = sext i16 [[TMP21]] to i32
; CHECK-NEXT:    [[MUL_CLONE:%.*]] = mul nsw i32 [[CONV5_CLONE]], [[CONV3_CLONE]]
; CHECK-NEXT:    [[CONV6_CLONE:%.*]] = sext i32 [[MUL_CLONE]] to i64
; CHECK-NEXT:    [[ADD_CLONE]] = add nsw i64 [[TMP19]], [[CONV6_CLONE]]
; CHECK-NEXT:    [[INC_CLONE]] = add nuw nsw i32 [[I_025_CLONE]], 1
; CHECK-NEXT:    [[EXITCOND_NOT_CLONE:%.*]] = icmp eq i32 [[INC_CLONE]], [[LEN]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT_CLONE]], label [[FOR_END85]], label [[FOR_BODY_CLONE]]
; CHECK:       if.then:
; CHECK-NEXT:    [[SUB:%.*]] = add nsw i32 [[CONV]], -15
; CHECK-NEXT:    [[SH_PROM:%.*]] = zext nneg i32 [[SUB]] to i64
; CHECK-NEXT:    [[SHL:%.*]] = shl i64 [[ACC_0_LCSSA]], [[SH_PROM]]
; CHECK-NEXT:    [[EXTRACT_T29:%.*]] = trunc i64 [[SHL]] to i16
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    [[SUB11:%.*]] = sub nsw i32 15, [[CONV]]
; CHECK-NEXT:    [[SH_PROM12:%.*]] = zext nneg i32 [[SUB11]] to i64
; CHECK-NEXT:    [[SHR13:%.*]] = ashr i64 [[ACC_0_LCSSA]], [[SH_PROM12]]
; CHECK-NEXT:    [[EXTRACT_T30:%.*]] = trunc i64 [[SHR13]] to i16
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    [[EXTRACT_T28:%.*]] = phi i16 [ [[EXTRACT_T30]], [[FOR_COND_CLEANUP_LOOPEXIT]] ], [ [[EXTRACT_T29]], [[FOR_BODY_7]] ]
; CHECK-NEXT:    store i16 [[EXTRACT_T28]], ptr [[DEST]], align 2
; CHECK-NEXT:    ret i32 0
;
entry:
  %conv = sext i8 %shift to i32
  %shr = lshr i32 32767, %conv
  %conv1 = zext nneg i32 %shr to i64
  %cmp24 = icmp sgt i32 %len, 0
  br i1 %cmp24, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %acc.0.lcssa = phi i64 [ %conv1, %entry ], [ %add, %for.body ]
  %cmp8 = icmp sgt i8 %shift, 15
  br i1 %cmp8, label %if.then, label %if.else

for.body:                                         ; preds = %for.body, %entry
  %acc.026 = phi i64 [ %add, %for.body ], [ %conv1, %entry ]
  %i.025 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  %arrayidx = getelementptr inbounds i16, ptr %src1, i32 %i.025
  %0 = load i16, ptr %arrayidx, align 2
  %conv3 = sext i16 %0 to i32
  %arrayidx4 = getelementptr inbounds i16, ptr %src2, i32 %i.025
  %1 = load i16, ptr %arrayidx4, align 2
  %conv5 = sext i16 %1 to i32
  %mul = mul nsw i32 %conv5, %conv3
  %conv6 = sext i32 %mul to i64
  %add = add nsw i64 %acc.026, %conv6
  %inc = add nuw nsw i32 %i.025, 1
  %exitcond.not = icmp eq i32 %inc, %len
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body

if.then:                                          ; preds = %for.cond.cleanup
  %sub = add nsw i32 %conv, -15
  %sh_prom = zext nneg i32 %sub to i64
  %shl = shl i64 %acc.0.lcssa, %sh_prom
  %extract.t29 = trunc i64 %shl to i16
  br label %if.end

if.else:                                          ; preds = %for.cond.cleanup
  %sub11 = sub nsw i32 15, %conv
  %sh_prom12 = zext nneg i32 %sub11 to i64
  %shr13 = ashr i64 %acc.0.lcssa, %sh_prom12
  %extract.t28 = trunc i64 %shr13 to i16
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %shr13.sink.off0 = phi i16 [ %extract.t28, %if.else ], [ %extract.t29, %if.then ]
  store i16 %shr13.sink.off0, ptr %dest, align 2
  ret i32 0
}

