; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt -S -mtriple=riscv32-esp-unknown-elf -passes=riscv-int-loop-unroll-and-remainder -riscv-int-loop-unroll-and-remainder=false < %s | FileCheck %s
; Function Attrs: nofree norecurse nosync nounwind memory(argmem: readwrite)
define dso_local noundef i32 @dspm_mult_s16_ansi(ptr nocapture noundef readonly %A, ptr nocapture noundef readonly %B, ptr nocapture noundef writeonly %C, i32 noundef %m, i32 noundef %n, i32 noundef %k, i32 noundef %shift) local_unnamed_addr {
; CHECK-LABEL: define dso_local noundef i32 @dspm_mult_s16_ansi(
; CHECK-SAME: ptr nocapture noundef readonly [[A:%.*]], ptr nocapture noundef readonly [[B:%.*]], ptr nocapture noundef writeonly [[C:%.*]], i32 noundef [[M:%.*]], i32 noundef [[N:%.*]], i32 noundef [[K:%.*]], i32 noundef [[SHIFT:%.*]]) local_unnamed_addr {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP63:%.*]] = icmp sgt i32 [[M]], 0
; CHECK-NEXT:    br i1 [[CMP63]], label [[FOR_COND1_PREHEADER_LR_PH:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.cond1.preheader.lr.ph:
; CHECK-NEXT:    [[SUB:%.*]] = add nsw i32 [[SHIFT]], -15
; CHECK-NEXT:    [[CMP261:%.*]] = icmp sgt i32 [[K]], 0
; CHECK-NEXT:    [[SHR:%.*]] = lshr i32 32767, [[SHIFT]]
; CHECK-NEXT:    [[CONV:%.*]] = zext nneg i32 [[SHR]] to i64
; CHECK-NEXT:    [[CMP111262:%.*]] = icmp sgt i32 [[N]], 0
; CHECK-NEXT:    [[CMP18:%.*]] = icmp sgt i32 [[SHIFT]], 15
; CHECK-NEXT:    [[SUB24:%.*]] = sub nsw i32 15, [[SHIFT]]
; CHECK-NEXT:    [[SH_PROM25:%.*]] = zext nneg i32 [[SUB24]] to i64
; CHECK-NEXT:    [[SH_PROM:%.*]] = zext nneg i32 [[SUB]] to i64
; CHECK-NEXT:    br label [[FOR_COND1_PREHEADER:%.*]]
; CHECK:       for.cond1.preheader:
; CHECK-NEXT:    [[I_064:%.*]] = phi i32 [ 0, [[FOR_COND1_PREHEADER_LR_PH]] ], [ [[INC35:%.*]], [[FOR_COND_CLEANUP3:%.*]] ]
; CHECK-NEXT:    br i1 [[CMP261]], label [[FOR_BODY4_LR_PH:%.*]], label [[FOR_COND_CLEANUP3]]
; CHECK:       for.body4.lr.ph:
; CHECK-NEXT:    [[MUL:%.*]] = mul nsw i32 [[I_064]], [[N]]
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i16, ptr [[A]], i32 [[MUL]]
; CHECK-NEXT:    [[MUL28:%.*]] = mul nsw i32 [[I_064]], [[K]]
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i16, ptr [[C]], i32 [[MUL28]]
; CHECK-NEXT:    br label [[FOR_BODY4:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret i32 0
; CHECK:       for.cond.cleanup3:
; CHECK-NEXT:    [[INC35]] = add nuw nsw i32 [[I_064]], 1
; CHECK-NEXT:    [[EXITCOND66_NOT:%.*]] = icmp eq i32 [[INC35]], [[M]]
; CHECK-NEXT:    br i1 [[EXITCOND66_NOT]], label [[FOR_COND_CLEANUP]], label [[FOR_COND1_PREHEADER]]
; CHECK:       for.body4:
; CHECK-NEXT:    [[J_062:%.*]] = phi i32 [ 0, [[FOR_BODY4_LR_PH]] ], [ [[INC32:%.*]], [[FOR_COND_CLEANUP8:%.*]] ]
; CHECK-NEXT:    [[INVARIANT_GEP:%.*]] = getelementptr i16, ptr [[B]], i32 [[J_062]]
; CHECK-NEXT:    br i1 [[CMP111262]], label [[FOR_BODY9_CLONE:%.*]], label [[FOR_COND_CLEANUP8]]
; CHECK:       for.cond.cleanup8:
; CHECK-NEXT:    [[ACC_0_LCSSA:%.*]] = phi i64 [ [[CONV]], [[FOR_BODY4]] ], [ [[ADD17_CLONE:%.*]], [[FOR_BODY9_CLONE]] ]
; CHECK-NEXT:    [[ARRAYIDX23:%.*]] = getelementptr i16, ptr [[TMP2]], i32 [[J_062]]
; CHECK-NEXT:    [[SHR26:%.*]] = ashr i64 [[ACC_0_LCSSA]], [[SH_PROM25]]
; CHECK-NEXT:    [[SHL:%.*]] = shl i64 [[ACC_0_LCSSA]], [[SH_PROM]]
; CHECK-NEXT:    [[SHR26_SINK:%.*]] = select i1 [[CMP18]], i64 [[SHL]], i64 [[SHR26]]
; CHECK-NEXT:    [[CONV27:%.*]] = trunc i64 [[SHR26_SINK]] to i16
; CHECK-NEXT:    store i16 [[CONV27]], ptr [[ARRAYIDX23]], align 2
; CHECK-NEXT:    [[INC32]] = add nuw nsw i32 [[J_062]], 1
; CHECK-NEXT:    [[EXITCOND65_NOT:%.*]] = icmp eq i32 [[INC32]], [[K]]
; CHECK-NEXT:    br i1 [[EXITCOND65_NOT]], label [[FOR_COND_CLEANUP3]], label [[FOR_BODY4]]
; CHECK:       for.body9:
; CHECK-NEXT:    [[S_060_CLONE:%.*]] = phi i32 [ [[INC_CLONE:%.*]], [[FOR_BODY9_CLONE]] ], [ 0, [[FOR_BODY4]] ]
; CHECK-NEXT:    [[ACC_059_CLONE:%.*]] = phi i64 [ [[ADD17_CLONE]], [[FOR_BODY9_CLONE]] ], [ [[CONV]], [[FOR_BODY4]] ]
; CHECK-NEXT:    [[ARRAYIDX_CLONE:%.*]] = getelementptr i16, ptr [[TMP1]], i32 [[S_060_CLONE]]
; CHECK-NEXT:    [[TMP19:%.*]] = load i16, ptr [[ARRAYIDX_CLONE]], align 2
; CHECK-NEXT:    [[CONV10_CLONE:%.*]] = sext i16 [[TMP19]] to i32
; CHECK-NEXT:    [[MUL11_CLONE:%.*]] = mul nsw i32 [[S_060_CLONE]], [[K]]
; CHECK-NEXT:    [[GEP_CLONE:%.*]] = getelementptr i16, ptr [[INVARIANT_GEP]], i32 [[MUL11_CLONE]]
; CHECK-NEXT:    [[TMP20:%.*]] = load i16, ptr [[GEP_CLONE]], align 2
; CHECK-NEXT:    [[CONV14_CLONE:%.*]] = sext i16 [[TMP20]] to i32
; CHECK-NEXT:    [[MUL15_CLONE:%.*]] = mul nsw i32 [[CONV14_CLONE]], [[CONV10_CLONE]]
; CHECK-NEXT:    [[CONV16_CLONE:%.*]] = sext i32 [[MUL15_CLONE]] to i64
; CHECK-NEXT:    [[ADD17_CLONE]] = add nsw i64 [[ACC_059_CLONE]], [[CONV16_CLONE]]
; CHECK-NEXT:    [[INC_CLONE]] = add nuw nsw i32 [[S_060_CLONE]], 1
; CHECK-NEXT:    [[EXITCOND_NOT_CLONE:%.*]] = icmp eq i32 [[INC_CLONE]], [[N]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT_CLONE]], label [[FOR_COND_CLEANUP8]], label [[FOR_BODY9_CLONE]]
;
entry:
  %cmp63 = icmp sgt i32 %m, 0
  br i1 %cmp63, label %for.cond1.preheader.lr.ph, label %for.cond.cleanup

for.cond1.preheader.lr.ph:                        ; preds = %entry
  %sub = add nsw i32 %shift, -15
  %cmp261 = icmp sgt i32 %k, 0
  %shr = lshr i32 32767, %shift
  %conv = zext nneg i32 %shr to i64
  %cmp658 = icmp sgt i32 %n, 0
  %cmp18 = icmp sgt i32 %shift, 15
  %sub24 = sub nsw i32 15, %shift
  %sh_prom25 = zext nneg i32 %sub24 to i64
  %sh_prom = zext nneg i32 %sub to i64
  br label %for.cond1.preheader

for.cond1.preheader:                              ; preds = %for.cond.cleanup3, %for.cond1.preheader.lr.ph
  %i.064 = phi i32 [ 0, %for.cond1.preheader.lr.ph ], [ %inc35, %for.cond.cleanup3 ]
  br i1 %cmp261, label %for.body4.lr.ph, label %for.cond.cleanup3

for.body4.lr.ph:                                  ; preds = %for.cond1.preheader
  %mul = mul nsw i32 %i.064, %n
  %0 = getelementptr i16, ptr %A, i32 %mul
  %mul28 = mul nsw i32 %i.064, %k
  %1 = getelementptr i16, ptr %C, i32 %mul28
  br label %for.body4

for.cond.cleanup:                                 ; preds = %for.cond.cleanup3, %entry
  ret i32 0

for.cond.cleanup3:                                ; preds = %for.cond.cleanup8, %for.cond1.preheader
  %inc35 = add nuw nsw i32 %i.064, 1
  %exitcond66.not = icmp eq i32 %inc35, %m
  br i1 %exitcond66.not, label %for.cond.cleanup, label %for.cond1.preheader

for.body4:                                        ; preds = %for.cond.cleanup8, %for.body4.lr.ph
  %j.062 = phi i32 [ 0, %for.body4.lr.ph ], [ %inc32, %for.cond.cleanup8 ]
  %invariant.gep = getelementptr i16, ptr %B, i32 %j.062
  br i1 %cmp658, label %for.body9, label %for.cond.cleanup8

for.cond.cleanup8:                                ; preds = %for.body9, %for.body4
  %acc.0.lcssa = phi i64 [ %conv, %for.body4 ], [ %add17, %for.body9 ]
  %arrayidx23 = getelementptr i16, ptr %1, i32 %j.062
  %shr26 = ashr i64 %acc.0.lcssa, %sh_prom25
  %shl = shl i64 %acc.0.lcssa, %sh_prom
  %shr26.sink = select i1 %cmp18, i64 %shl, i64 %shr26
  %conv27 = trunc i64 %shr26.sink to i16
  store i16 %conv27, ptr %arrayidx23, align 2
  %inc32 = add nuw nsw i32 %j.062, 1
  %exitcond65.not = icmp eq i32 %inc32, %k
  br i1 %exitcond65.not, label %for.cond.cleanup3, label %for.body4

for.body9:                                        ; preds = %for.body9, %for.body4
  %s.060 = phi i32 [ %inc, %for.body9 ], [ 0, %for.body4 ]
  %acc.059 = phi i64 [ %add17, %for.body9 ], [ %conv, %for.body4 ]
  %arrayidx = getelementptr i16, ptr %0, i32 %s.060
  %2 = load i16, ptr %arrayidx, align 2
  %conv10 = sext i16 %2 to i32
  %mul11 = mul nsw i32 %s.060, %k
  %gep = getelementptr i16, ptr %invariant.gep, i32 %mul11
  %3 = load i16, ptr %gep, align 2
  %conv14 = sext i16 %3 to i32
  %mul15 = mul nsw i32 %conv14, %conv10
  %conv16 = sext i32 %mul15 to i64
  %add17 = add nsw i64 %acc.059, %conv16
  %inc = add nuw nsw i32 %s.060, 1
  %exitcond.not = icmp eq i32 %inc, %n
  br i1 %exitcond.not, label %for.cond.cleanup8, label %for.body9
}
