; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt -S -mtriple=riscv32-esp-unknown-elf -passes=riscv-custom-licm -riscv-custom-licm=true < %s | FileCheck %s

; Function Attrs: nofree nounwind memory(write)
define dso_local void @dsps_wind_flat_top_f32(ptr nocapture noundef writeonly %window, i32 noundef %len) local_unnamed_addr {
; CHECK-LABEL: define dso_local void @dsps_wind_flat_top_f32(
; CHECK-SAME: ptr noundef writeonly captures(none) [[WINDOW:%.*]], i32 noundef [[LEN:%.*]]) local_unnamed_addr {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP42:%.*]] = icmp sgt i32 [[LEN]], 0
; CHECK-NEXT:    br i1 [[CMP42]], label [[FOR_BODY_LR_PH:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body.lr.ph:
; CHECK-NEXT:    [[SUB:%.*]] = add nsw i32 [[LEN]], -1
; CHECK-NEXT:    [[CONV:%.*]] = sitofp i32 [[SUB]] to float
; CHECK-NEXT:    [[DIV:%.*]] = fdiv float 1.000000e+00, [[CONV]]
; CHECK-NEXT:    [[CONV4:%.*]] = fpext float [[DIV]] to double
; CHECK-NEXT:    [[MUL1:%.*]] = fmul double [[CONV4]], 0x401921FB54442D18
; CHECK-NEXT:    [[CONV22:%.*]] = fptrunc double [[MUL1]] to float
; CHECK-NEXT:    [[MUL33:%.*]] = fmul float [[CONV22]], 2.000000e+00
; CHECK-NEXT:    [[MUL4:%.*]] = fmul float [[CONV22]], 3.000000e+00
; CHECK-NEXT:    [[MUL54:%.*]] = fmul float [[CONV22]], 4.000000e+00
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
; CHECK:       for.body:
; CHECK-NEXT:    [[I_043:%.*]] = phi i32 [ 0, [[FOR_BODY_LR_PH]] ], [ [[INC:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CONV5:%.*]] = sitofp i32 [[I_043]] to float
; CHECK-NEXT:    [[MUL6:%.*]] = fmul float [[CONV22]], [[CONV5]]
; CHECK-NEXT:    [[CALL:%.*]] = tail call float @cosf(float noundef [[MUL6]])
; CHECK-NEXT:    [[TMP0:%.*]] = tail call float @llvm.fmuladd.f32(float [[CALL]], float 0xBFDAAA1780000000, float 0x3FCB981740000000)
; CHECK-NEXT:    [[MUL9:%.*]] = fmul float [[MUL33]], [[CONV5]]
; CHECK-NEXT:    [[CALL14:%.*]] = tail call float @cosf(float noundef [[MUL9]])
; CHECK-NEXT:    [[TMP1:%.*]] = tail call float @llvm.fmuladd.f32(float [[CALL14]], float 0x3FD1BEAE00000000, float [[TMP0]])
; CHECK-NEXT:    [[MUL125:%.*]] = fmul float [[MUL4]], [[CONV5]]
; CHECK-NEXT:    [[CALL22:%.*]] = tail call float @cosf(float noundef [[MUL125]])
; CHECK-NEXT:    [[TMP2:%.*]] = tail call float @llvm.fmuladd.f32(float [[CALL22]], float 0xBFB5656E00000000, float [[TMP1]])
; CHECK-NEXT:    [[MUL15:%.*]] = fmul float [[MUL54]], [[CONV5]]
; CHECK-NEXT:    [[CALL30:%.*]] = tail call float @cosf(float noundef [[MUL15]])
; CHECK-NEXT:    [[TMP3:%.*]] = tail call float @llvm.fmuladd.f32(float [[CALL30]], float 0x3F7C74D7E0000000, float [[TMP2]])
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[WINDOW]], i32 [[I_043]]
; CHECK-NEXT:    store float [[TMP3]], ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_043]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i32 [[INC]], [[LEN]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY]]
;
entry:
  %cmp42 = icmp sgt i32 %len, 0
  br i1 %cmp42, label %for.body.lr.ph, label %for.cond.cleanup

for.body.lr.ph:                                   ; preds = %entry
  %sub = add nsw i32 %len, -1
  %conv = sitofp i32 %sub to float
  %div = fdiv float 1.000000e+00, %conv
  %conv4 = fpext float %div to double
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body, %entry
  ret void

for.body:                                         ; preds = %for.body, %for.body.lr.ph
  %i.043 = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %for.body ]
  %mul = shl nuw nsw i32 %i.043, 1
  %conv2 = sitofp i32 %mul to double
  %mul3 = fmul double %conv2, 0x400921FB54442D18
  %mul5 = fmul double %mul3, %conv4
  %conv6 = fptrunc double %mul5 to float
  %call = tail call float @cosf(float noundef %conv6)
  %0 = tail call float @llvm.fmuladd.f32(float %call, float 0xBFDAAA1780000000, float 0x3FCB981740000000)
  %mul8 = shl nsw i32 %i.043, 2
  %conv9 = sitofp i32 %mul8 to double
  %mul10 = fmul double %conv9, 0x400921FB54442D18
  %mul12 = fmul double %mul10, %conv4
  %conv13 = fptrunc double %mul12 to float
  %call14 = tail call float @cosf(float noundef %conv13)
  %1 = tail call float @llvm.fmuladd.f32(float %call14, float 0x3FD1BEAE00000000, float %0)
  %mul16 = mul nuw nsw i32 %i.043, 6
  %conv17 = sitofp i32 %mul16 to double
  %mul18 = fmul double %conv17, 0x400921FB54442D18
  %mul20 = fmul double %mul18, %conv4
  %conv21 = fptrunc double %mul20 to float
  %call22 = tail call float @cosf(float noundef %conv21)
  %2 = tail call float @llvm.fmuladd.f32(float %call22, float 0xBFB5656E00000000, float %1)
  %mul24 = shl nsw i32 %i.043, 3
  %conv25 = sitofp i32 %mul24 to double
  %mul26 = fmul double %conv25, 0x400921FB54442D18
  %mul28 = fmul double %mul26, %conv4
  %conv29 = fptrunc double %mul28 to float
  %call30 = tail call float @cosf(float noundef %conv29)
  %3 = tail call float @llvm.fmuladd.f32(float %call30, float 0x3F7C74D7E0000000, float %2)
  %arrayidx = getelementptr inbounds float, ptr %window, i32 %i.043
  store float %3, ptr %arrayidx, align 4
  %inc = add nuw nsw i32 %i.043, 1
  %exitcond.not = icmp eq i32 %inc, %len
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(write)
declare dso_local float @cosf(float noundef) local_unnamed_addr

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.fmuladd.f32(float, float, float)

